<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SCBVJH1HLS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SCBVJH1HLS');
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": ["SoftwareApplication", "Game"],
  "name": "Silent Sand",
  "url": "https://silentsand.me",
  "description": "A free virtual mindfulness tool that lets you create satisfying sand patterns in a digital Japanese rock garden.",
  "genre": ["Simulation", "Relaxation", "Casual"],
  "applicationCategory": "GameApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "120"
  }
}
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Silent Sand - Virtual Mindfulness & Sand Raking</title>
<meta name="description" content="Experience peace with Silent Sand. Create satisfying sand patterns, practice mindfulness, and reduce stress with this free virtual Japanese rock garden simulator.">
<link rel="icon" type="image/png" href="img.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-y: auto;
    font-family: 'Segoe UI', system-ui, sans-serif;
    user-select: none;
    padding: 40px 0;
  }
  h1 {
    color: #c2a67d;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    font-size: 20px;
    margin-bottom: 16px;
    opacity: 0.7;
  }
  canvas {
    display: block;
    cursor: none;
    box-shadow: 0 0 60px rgba(0,0,0,0.5);
  }
  .controls {
    margin-top: 16px;
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 800px;
  }
  button {
    background: none;
    border: 1px solid #5a4a35;
    color: #c2a67d;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  button:hover { background: #5a4a35; color: #e8d5b7; }
  button.active { background: #5a4a35; color: #e8d5b7; }

  .size-controls { display: flex; align-items: center; gap: 8px; }
  .size-controls span { color: #c2a67d; font-size: 12px; letter-spacing: 0.1em; font-weight: 500; }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100px;
    height: 3px;
    background: #5a4a35;
    border-radius: 2px;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    background: #c2a67d;
    border-radius: 50%;
    cursor: pointer;
  }
  .tine-controls { display: flex; align-items: center; gap: 8px; }
  .tine-controls span { color: #c2a67d; font-size: 12px; letter-spacing: 0.1em; font-weight: 500; }
  .tine-controls .tine-label { color: #c2a67d; min-width: 8px; text-align: center; }
  .info-i {
    display: inline-flex; align-items: center; justify-content: center;
    width: 13px; height: 13px; border-radius: 50%;
    border: 1px solid #5a4a3566; color: #5a4a3588;
    font-size: 9px; font-style: italic; font-family: Georgia, serif;
    cursor: default; position: relative; flex-shrink: 0;
  }
  .info-i .info-tip {
    display: none; position: absolute; bottom: 20px; left: 50%;
    transform: translateX(-50%); white-space: nowrap;
    background: #2a2218; color: #c2a67dcc; font-style: normal;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 11px; padding: 4px 8px; border-radius: 4px;
    pointer-events: none; letter-spacing: 0.02em; z-index: 10;
  }
  .info-i:hover .info-tip { display: block; }

  /* Custom Checkbox Toggle */
  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 18px;
    margin-left: 4px;
  }
  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #2a2218;
    border: 1px solid #5a4a35;
    transition: .4s;
    border-radius: 18px;
  }
  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 12px;
    width: 12px;
    left: 2px;
    bottom: 2px;
    background-color: #5a4a35;
    transition: .4s;
    border-radius: 50%;
  }
  input:checked + .toggle-slider {
    background-color: #5a4a35;
  }
  input:checked + .toggle-slider:before {
    transform: translateX(18px);
    background-color: #c2a67d;
  }

  /* Tabs */
  .tabs {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-bottom: 16px;
    border-bottom: 1px solid #5a4a3544;
  }
  .tab-btn {
    background: none;
    border: none;
    color: #5a4a35;
    padding: 8px 12px;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    opacity: 0.6;
    transition: all 0.3s;
    border-bottom: 2px solid transparent;
  }
  .tab-btn:hover { opacity: 1; color: #c2a67d; }
  .tab-btn.active {
    opacity: 1;
    color: #c2a67d;
    border-bottom: 2px solid #c2a67d;
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Mirror toggle buttons */
  .mirror-controls {
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .mirror-controls span {
    color: #c2a67d;
    font-size: 12px;
    letter-spacing: 0.1em;
    font-weight: 500;
  }
  .mirror-btn {
    width: 28px;
    height: 28px;
    padding: 0;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    background: #2a2218;
    border: 1px solid #5a4a35;
    color: #5a4a35;
    font-size: 16px;
    line-height: 1;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.3s;
    letter-spacing: 0;
    text-transform: none;
  }
  .mirror-btn:hover { background: #3a3228; color: #c2a67d; }
  .mirror-btn.active { background: #5a4a35; color: #c2a67d; }

  /* Symmetry guide lines */
  .sym-line {
    stroke: #c2a67d;
    stroke-width: 1.5;
    opacity: 0.45;
    stroke-dasharray: 8,5;
  }
</style>
</head>
<body>
<h1>silentsand.me</h1>
<div style="position: relative; display: inline-block; overflow: hidden; border-radius: 6px;">
  <canvas id="garden"></canvas>
  <img id="guideOverlay" src="" alt="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; object-fit: contain;">
  <svg id="symmetryLines" style="position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; display:none;">
    <line id="symV" class="sym-line" x1="50%" y1="0" x2="50%" y2="100%" style="display:none;" />
    <line id="symH" class="sym-line" x1="0" y1="50%" x2="100%" y2="50%" style="display:none;" />
    <line id="symD1" class="sym-line" x1="0" y1="0" x2="100%" y2="100%" style="display:none;" />
    <line id="symD2" class="sym-line" x1="100%" y1="0" x2="0" y2="100%" style="display:none;" />
    <circle id="symCenter" cx="50%" cy="50%" r="3" fill="#c2a67d" style="display:none; opacity: 0.6;" />
  </svg>
</div>
<div style="width: 100%; max-width: 1120px; margin-top: 16px; padding: 0 20px;">
  <button id="clearBtn" style="width: 100%;">Clear Sand</button>
</div>
<div class="controls" style="margin-top: 16px;">
  <button id="settingsBtn" class="active">Tools</button>
</div>

<div id="settingsPanel" style="margin-top: 16px; padding-top: 8px; border-top: 1px solid #5a4a3544;">
  <div class="tabs">
    <button class="tab-btn active" data-tab="tab-rake">Rake</button>
    <button class="tab-btn" data-tab="tab-guide">Image</button>
    <button class="tab-btn" data-tab="tab-tuning">Tuning</button>
  </div>

  <div id="tab-rake" class="tab-content active">
    <div class="controls">
      <div class="tine-controls">
        <span>Tines</span>
        <input type="range" id="tineSlider" min="1" max="11" step="1" value="6">
        <span class="tine-label" id="tineLabel">6</span>
      </div>
      <div class="size-controls">
        <span>Gap</span>
        <input type="range" id="gapSlider" min="1" max="5" step="0.1" value="3">
      </div>
      <div class="size-controls">
        <span>Size</span>
        <input type="range" id="sizeSlider" min="4" max="20" value="6">
      </div>
      <div class="mirror-controls">
        <span>Mirror</span>
        <button id="mirrorVBtn" class="mirror-btn" title="Vertical axis">&#124;</button>
        <button id="mirrorHBtn" class="mirror-btn" title="Horizontal axis">&mdash;</button>
        <button id="mirrorDBtn" class="mirror-btn" title="Diagonal axes">&times;</button>
      </div>
      <div class="size-controls" style="margin-left: 8px; border-left: 1px solid #5a4a3544; padding-left: 8px;">
        <span>Center Align</span>
        <label class="toggle-switch">
          <input type="checkbox" id="alignCenterToggle">
          <span class="toggle-slider"></span>
        </label>
      </div>
    </div>
    <div style="margin-top: 12px; text-align: center;">
      <span style="color: #c2a67d; font-size: 13px; font-weight: 500; opacity: 0.8; letter-spacing: 0.05em;">
        Scroll wheel to rotate rake
      </span>
    </div>
  </div>

  <div id="tab-guide" class="tab-content">
    <div class="controls">
      <input type="file" id="guideUpload" accept="image/*" style="display: none;">
      <button id="guideBtn" style="width: auto;">Upload Guide</button>
      <div class="size-controls">
        <span>Show</span>
        <label class="toggle-switch">
          <input type="checkbox" id="guideToggle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="size-controls">
        <span>Opacity</span>
        <input type="range" id="guideOpacity" min="0" max="100" value="0">
      </div>
      <div class="size-controls">
        <span>Zoom</span>
        <input type="range" id="guideZoom" min="50" max="300" value="100">
      </div>
    </div>
    <div class="controls" style="margin-top: 8px;">
      <div class="size-controls">
        <span>X</span>
        <input type="range" id="guideX" min="-400" max="400" value="0">
      </div>
      <div class="size-controls">
        <span>Y</span>
        <input type="range" id="guideY" min="-400" max="400" value="0">
      </div>
    </div>
  </div>

  <div id="tab-tuning" class="tab-content">
    <div class="controls">
      <div class="size-controls">
        <span>Depth</span>
        <input type="range" id="dbgDepth" min="0.05" max="0.60" step="0.01" value="0.38">
        <span class="tine-label" id="dbgDepthLabel">0.38</span>
      </div>
      <div class="size-controls">
        <span>Rim</span>
        <input type="range" id="dbgRim" min="0.02" max="0.25" step="0.01" value="0.12">
        <span class="tine-label" id="dbgRimLabel">0.12</span>
      </div>
      <div class="size-controls">
        <span>Light</span>
        <input type="range" id="dbgLight" min="0.10" max="0.80" step="0.01" value="0.40">
        <span class="tine-label" id="dbgLightLabel">0.40</span>
      </div>
      <div class="size-controls">
        <span>Blend</span>
        <input type="range" id="dbgBlend" min="0.20" max="0.80" step="0.01" value="0.55">
        <span class="tine-label" id="dbgBlendLabel">0.55</span>
      </div>
    </div>
    <div class="controls" style="margin-top:8px;">
      <div class="size-controls">
        <span>Step</span>
        <input type="range" id="dbgStep" min="0.03" max="0.50" step="0.01" value="0.22">
        <span class="tine-label" id="dbgStepLabel">0.22</span>
        <span class="info-i">i<span class="info-tip">Stroke density. Higher = faster, coarser</span></span>
      </div>
      <div class="size-controls">
        <span>Spread</span>
        <input type="range" id="dbgSpread" min="1" max="4" step="1" value="1">
        <span class="tine-label" id="dbgSpreadLabel">1</span>
        <span class="info-i">i<span class="info-tip">Sand spread radius. Higher = slower, wider piles</span></span>
      </div>
      <div class="size-controls">
        <span>FwdD</span>
        <input type="range" id="dbgFwdD" min="0.20" max="2.00" step="0.01" value="0.59">
        <span class="tine-label" id="dbgFwdDLabel">0.59</span>
        <span class="info-i">i<span class="info-tip">Forward push distance. Higher = sand thrown further ahead</span></span>
      </div>
      <div class="size-controls">
        <span>SideD</span>
        <input type="range" id="dbgSideD" min="0.10" max="1.50" step="0.01" value="0.66">
        <span class="tine-label" id="dbgSideDLabel">0.66</span>
        <span class="info-i">i<span class="info-tip">Side push distance. Higher = wider rim banks</span></span>
      </div>
      <div class="size-controls">
        <span>NormD</span>
        <input type="range" id="dbgNormD" min="1" max="6" step="1" value="4">
        <span class="tine-label" id="dbgNormDLabel">4</span>
        <span class="info-i">i<span class="info-tip">Lighting sample distance. Higher = smoother, softer shading</span></span>
      </div>
      <div class="size-controls">
        <span>Noise</span>
        <input type="range" id="dbgNoise" min="0.00" max="1.00" step="0.01" value="0.89">
        <span class="tine-label" id="dbgNoiseLabel">0.89</span>
        <span class="info-i">i<span class="info-tip">Sand grain texture. Higher = heavier grain</span></span>
      </div>
    </div>
  </div>
</div>

<div class="seo-content" style="max-width: 800px; margin: 40px auto; padding: 0 20px; color: #c2a67d; opacity: 0.9;">
  <section style="margin-bottom: 40px; text-align: center;">
    <h2 style="font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; font-size: 18px; margin-bottom: 12px; border-bottom: 1px solid #5a4a3544; display: inline-block; padding-bottom: 4px;">About Silent Sand</h2>
    <p style="line-height: 1.6; font-size: 15px;">
      <strong>Silent Sand</strong> is a free virtual zen garden tool that lets you create satisfying sand patterns in a digital Japanese rock garden. Designed for <em>stress reduction</em> and meditation, it offers a calming, creative escape directly in your browser. Whether you are looking to practice mindfulness or simply enjoy the <em>Japanese aesthetic</em> of raking sand, this simulator provides a peaceful retreat.
    </p>
  </section>

  <section>
    <h2 style="font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; font-size: 18px; margin-bottom: 20px; border-bottom: 1px solid #5a4a3544; padding-bottom: 4px;">Frequently Asked Questions</h2>
    
    <article style="margin-bottom: 24px;">
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">How to play a virtual zen garden?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Playing is simple and intuitive. Use your mouse or touchscreen to rake the sand. 
        <strong>Click and drag</strong> to create grooves. You can adjust the <strong>rake size</strong>, <strong>tine count</strong>, and <strong>spacing</strong> using the "Tools" menu. 
        On desktop, use the <strong>scroll wheel</strong> to rotate the rake for precise patterns. The goal is to create flowing, continuous lines that evoke a sense of water or ripples, a core practice in creating a traditional <em>Karesansui</em> (dry landscape) garden.
      </p>
    </article>

    <article style="margin-bottom: 24px;">
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">What are the benefits of digital meditation?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Digital meditation tools like this online zen garden help lower cortisol levels and improve focus. By engaging in a repetitive, creative task (raking sand), you can achieve a "flow state" similar to traditional meditation. It provides a quick mental break, allowing you to reset your mind, reduce anxiety, and return to your tasks with renewed clarity.
      </p>
    </article>

    <article>
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">Is this Zen Garden free to use?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Yes, <strong>Silent Sand</strong> is completely free and accessible from any modern web browser on desktop or mobile. There are no downloads or installations required to start your mindfulness journey.
      </p>
    </article>
  </section>
</div>

<script>
const canvas = document.getElementById('garden');
const ctx = canvas.getContext('2d');
const clearBtn = document.getElementById('clearBtn');

// --- Cached slider values (optimization #3) ---
const cached = {};

const W = Math.min(1120, window.innerWidth - 40);
const H = Math.min(630, window.innerHeight - 120);
canvas.width = W;
canvas.height = H;

// --- Sand color presets ---
const SAND_COLORS = [
  [210, 190, 160], // cream (default)
  [185, 110, 70],  // terracotta
  [100, 75, 55],   // dark brown
  [160, 160, 155]  // grey
];

// --- Data model ---
const totalPixels = W * H;
const sandHeight = new Float32Array(totalPixels);
const sandR = new Float32Array(totalPixels);
const sandG = new Float32Array(totalPixels);
const sandB = new Float32Array(totalPixels);
const noiseMap = new Float32Array(totalPixels);

// --- Reuse ImageData buffer (optimization #5) ---
const imageData = ctx.createImageData(W, H);
const imageDataBuf = imageData.data;

// --- Pre-compute gaussian kernel as flat typed arrays ---
const MAX_KERNEL = 81; // (2*4+1)^2 = max possible entries
let gaussDx = new Int8Array(MAX_KERNEL);
let gaussDy = new Int8Array(MAX_KERNEL);
let gaussW = new Float32Array(MAX_KERNEL);
let gaussLen = 0;
let builtSpreadR = -1;

function rebuildGaussKernel() {
  const r = cached.spread;
  if (r === builtSpreadR) return;
  builtSpreadR = r;
  const sigma = r * 0.75;
  const invTwoSigma2 = 1 / (2 * sigma * sigma);
  let count = 0;
  let total = 0;
  for (let sy = -r; sy <= r; sy++) {
    for (let sx = -r; sx <= r; sx++) {
      const d2 = sx * sx + sy * sy;
      if (d2 > r * r) continue;
      const w = Math.exp(-d2 * invTwoSigma2);
      gaussDx[count] = sx;
      gaussDy[count] = sy;
      gaussW[count] = w;
      total += w;
      count++;
    }
  }
  const invTotal = 1 / total;
  for (let i = 0; i < count; i++) gaussW[i] *= invTotal;
  gaussLen = count;
}

// --- Pre-allocated displacement buffers (optimization #4) ---
const MAX_R = 20;
const MAX_DISP = (2 * MAX_R + 1) * (2 * MAX_R + 1);
const dispIdx = new Int32Array(MAX_DISP);
const dispAmount = new Float32Array(MAX_DISP);
const dispSrcR = new Float32Array(MAX_DISP);
const dispSrcG = new Float32Array(MAX_DISP);
const dispSrcB = new Float32Array(MAX_DISP);

// --- Dirty region tracking (optimization #2) ---
let dirtyMinX = 0, dirtyMinY = 0, dirtyMaxX = W - 1, dirtyMaxY = H - 1;
let dirtyEmpty = false;

function markDirty(x, y, radius) {
  const r = Math.ceil(radius);
  const x0 = Math.max(0, Math.floor(x) - r);
  const y0 = Math.max(0, Math.floor(y) - r);
  const x1 = Math.min(W - 1, Math.ceil(x) + r);
  const y1 = Math.min(H - 1, Math.ceil(y) + r);
  if (dirtyEmpty) {
    dirtyMinX = x0; dirtyMinY = y0;
    dirtyMaxX = x1; dirtyMaxY = y1;
    dirtyEmpty = false;
  } else {
    if (x0 < dirtyMinX) dirtyMinX = x0;
    if (y0 < dirtyMinY) dirtyMinY = y0;
    if (x1 > dirtyMaxX) dirtyMaxX = x1;
    if (y1 > dirtyMaxY) dirtyMaxY = y1;
  }
}

function markFullDirty() {
  dirtyMinX = 0; dirtyMinY = 0;
  dirtyMaxX = W - 1; dirtyMaxY = H - 1;
  dirtyEmpty = false;
}

function resetDirty() {
  dirtyEmpty = true;
}

// --- rAF render coalescing (optimization #1) ---
let renderScheduled = false;
function requestRender() {
  if (!renderScheduled) {
    renderScheduled = true;
    requestAnimationFrame(() => { renderScheduled = false; render(); });
  }
}

// --- Slider config (single source of truth) ---
const SLIDER_CONFIG = [
  { id: 'sizeSlider', key: 'tineRadius', parse: parseInt, onChange() { markCursorDirty(); requestRender(); } },
  { id: 'tineSlider', key: 'tineCount', parse: parseInt, labelId: 'tineLabel', onChange() { markCursorDirty(); requestRender(); } },
  { id: 'gapSlider', key: 'gapMul', parse: parseFloat, onChange() { markCursorDirty(); requestRender(); } },
  { id: 'dbgDepth', key: 'depth', parse: parseFloat, labelId: 'dbgDepthLabel', onChange() { tineProfileR = -1; markFullDirty(); requestRender(); } },
  { id: 'dbgRim', key: 'rim', parse: parseFloat, labelId: 'dbgRimLabel', onChange() { tineProfileR = -1; markFullDirty(); requestRender(); } },
  { id: 'dbgLight', key: 'light', parse: parseFloat, labelId: 'dbgLightLabel', onChange() { markFullDirty(); requestRender(); } },
  { id: 'dbgBlend', key: 'blend', parse: parseFloat, labelId: 'dbgBlendLabel' },
  { id: 'dbgStep', key: 'step', parse: parseFloat, labelId: 'dbgStepLabel' },
  { id: 'dbgSpread', key: 'spread', parse: parseInt, labelId: 'dbgSpreadLabel', onChange() { rebuildGaussKernel(); } },
  { id: 'dbgFwdD', key: 'fwdD', parse: parseFloat, labelId: 'dbgFwdDLabel' },
  { id: 'dbgSideD', key: 'sideD', parse: parseFloat, labelId: 'dbgSideDLabel' },
  { id: 'dbgNormD', key: 'normD', parse: parseInt, labelId: 'dbgNormDLabel', onChange() { markFullDirty(); requestRender(); } },
  { id: 'dbgNoise', key: 'noise', parse: parseFloat, labelId: 'dbgNoiseLabel', onChange() { markFullDirty(); requestRender(); } },
];

const sliderEls = {};

function setupSliders() {
  for (const def of SLIDER_CONFIG) {
    const el = document.getElementById(def.id);
    const labelEl = def.labelId ? document.getElementById(def.labelId) : null;
    // Reset to HTML default (override browser autofill)
    el.value = el.getAttribute('value');
    sliderEls[def.key] = { el, labelEl };
    cached[def.key] = def.parse(el.value);
    if (labelEl) labelEl.textContent = el.value;

    el.addEventListener('input', () => {
      cached[def.key] = def.parse(el.value);
      if (labelEl) labelEl.textContent = el.value;
      if (def.onChange) def.onChange();
    });
  }
}

function initSand() {
  const def = SAND_COLORS[0];
  for (let i = 0; i < totalPixels; i++) {
    sandHeight[i] = 1.0;
    sandR[i] = def[0];
    sandG[i] = def[1];
    sandB[i] = def[2];
  }
}

function generateNoiseMap() {
  for (let i = 0; i < totalPixels; i++) {
    const fine = (Math.random() - 0.5) * 10;
    const coarse = Math.random() < 0.03 ? (Math.random() - 0.5) * 16 : 0;
    noiseMap[i] = fine + coarse;
  }
}

function clearSand() {
  initSand();
  // Add fine random variation for a natural untouched look
  for (let i = 0; i < totalPixels; i++) {
    sandHeight[i] += (Math.random() - 0.5) * 0.3;
    sandHeight[i] = Math.max(0.1, Math.min(1.5, sandHeight[i]));
  }
  generateNoiseMap();
  markFullDirty();
  requestRender();
}

// --- Tine helpers ---
function getTineCount() {
  return cached.tineCount;
}

function getRakeTineOffsets(tineRadius) {
  const count = cached.tineCount;
  const spacing = cached.gapMul * tineRadius;
  const offsets = [];
  for (let i = 0; i < count; i++) {
    offsets.push((i - (count - 1) / 2) * spacing);
  }
  return offsets;
}

// --- Mirror symmetry state ---
let mirrorV = false;  // vertical axis (left/right)
let mirrorH = false;  // horizontal axis (top/bottom)
let mirrorD = false;  // diagonal axes (8-way)
let alignCenter = false; // center alignment

// --- Helper for alignment ---
function getPerpAt(x, y) {
  if (alignCenter) {
    const dx = x - W / 2;
    const dy = y - H / 2;
    const len = Math.sqrt(dx * dx + dy * dy);
    if (len > 0.001) {
      return [dx / len, dy / len];
    }
    return [1, 0];
  }
  return getRakePerp();
}

// --- Drawing state ---
let drawing = false;
let lastX = -1, lastY = -1;
let rakeAngle = 0;
let mouseX = -1, mouseY = -1;
let onCanvas = false;
// Track stroke direction for displacement
let strokeDX = 0, strokeDY = 0;

function getRakePerp() {
  return [Math.cos(rakeAngle), Math.sin(rakeAngle)];
}

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  if (e.touches) {
    return [
      (e.touches[0].clientX - rect.left) * scaleX,
      (e.touches[0].clientY - rect.top) * scaleY
    ];
  }
  return [
    (e.clientX - rect.left) * scaleX,
    (e.clientY - rect.top) * scaleY
  ];
}

// --- Pre-computed tine height profile LUT ---
let tineProfileR = -1;
let tineProfileDepth = -1;
let tineProfileRim = -1;
let tineProfile = null; // Float32Array, size (2*r+1)²
let tineProfileStride = 0;

function rebuildTineProfile(r) {
  const curDepth = cached.depth;
  const curRim = cached.rim;
  if (r === tineProfileR && curDepth === tineProfileDepth && curRim === tineProfileRim) return;
  tineProfileR = r;
  tineProfileDepth = curDepth;
  tineProfileRim = curRim;
  const side = 2 * r + 1;
  tineProfileStride = side;
  tineProfile = new Float32Array(side * side);
  const rSq = r * r;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const dist2 = dx * dx + dy * dy;
      if (dist2 > rSq) {
        tineProfile[(dy + r) * side + (dx + r)] = -1; // sentinel: outside
        continue;
      }
      const t = Math.sqrt(dist2) / r;
      // Smooth groove: cubic ease for the channel, gentle rim
      let h;
      if (t < 0.6) {
        const u = t / 0.6;
        h = 1.0 - curDepth * (1 - u * u * u);
      } else if (t < 0.85) {
        const u = (t - 0.6) / 0.25;
        h = 1.0 + u * curRim;
      } else {
        const u = (t - 0.85) / 0.15;
        h = (1.0 + curRim) - u * curRim;
      }
      tineProfile[(dy + r) * side + (dx + r)] = h;
    }
  }
}

// --- Sand displacement in carveTine (optimizations #4, #6) ---
function carveTine(x, y, radius, dirX, dirY) {
  const r = Math.floor(radius);
  rebuildTineProfile(r);
  const ix = Math.round(x);
  const iy = Math.round(y);

  // Normalize stroke direction
  const dirLenSq = dirX * dirX + dirY * dirY;
  let ndx = 0, ndy = 0;
  if (dirLenSq > 0.000001) {
    const dirLen = Math.sqrt(dirLenSq);
    ndx = dirX / dirLen;
    ndy = dirY / dirLen;
  }
  // Perpendicular (for side displacement)
  const perpX = -ndy;
  const perpY = ndx;

  // Cache blend value and pre-compute inverse
  const blendTarget = cached.blend;
  const blendInv = 1 - blendTarget;

  // Pass 1: figure out how much sand to remove at each pixel
  let dispCount = 0;

  for (let dy = -r; dy <= r; dy++) {
    const py = iy + dy;
    if (py < 0 || py >= H) continue;
    const rowBase = py * W;
    const profileRowBase = (dy + r) * tineProfileStride + r;
    for (let dx = -r; dx <= r; dx++) {
      const px = ix + dx;
      if (px < 0 || px >= W) continue;

      const targetHeight = tineProfile[profileRowBase + dx];
      if (targetHeight < 0) continue; // outside radius

      const idx = rowBase + px;
      const currentH = sandHeight[idx];

      const blended = currentH * blendInv + targetHeight * blendTarget;
      if (currentH > blended) {
        const displaced = currentH - blended;
        dispIdx[dispCount] = idx;
        dispAmount[dispCount] = displaced;
        dispSrcR[dispCount] = sandR[idx];
        dispSrcG[dispCount] = sandG[idx];
        dispSrcB[dispCount] = sandB[idx];
        dispCount++;
        sandHeight[idx] = blended;
      }
    }
  }

  // Mark the carve area dirty
  markDirty(ix, iy, r + 2);

  // Pass 2: distribute displaced sand using flat gaussian kernel arrays
  const fwdDist = r * cached.fwdD;
  const sideDist = r * cached.sideD;
  const spreadR = cached.spread;
  // Deposit spread radius for dirty marking
  const depositMarkR = spreadR + 2;
  // Interior bounds — if deposit center is inside these, all kernel entries are in-bounds
  const interiorMinX = spreadR;
  const interiorMinY = spreadR;
  const interiorMaxX = W - 1 - spreadR;
  const interiorMaxY = H - 1 - spreadR;
  const kLen = gaussLen;

  for (let i = 0; i < dispCount; i++) {
    const srcIdx = dispIdx[i];
    const displaced = dispAmount[i];
    const sR = dispSrcR[i];
    const sG = dispSrcG[i];
    const sB = dispSrcB[i];
    const srcPx = srcIdx % W;
    const srcPy = (srcIdx - srcPx) / W;

    // 3 deposit centers inlined (forward, sideA, sideB)
    const depCX0 = Math.round(srcPx + ndx * fwdDist);
    const depCY0 = Math.round(srcPy + ndy * fwdDist);
    const depAmt0 = displaced * 0.70;

    const depCX1 = Math.round(srcPx + perpX * sideDist);
    const depCY1 = Math.round(srcPy + perpY * sideDist);
    const depAmt1 = displaced * 0.15;

    const depCX2 = Math.round(srcPx - perpX * sideDist);
    const depCY2 = Math.round(srcPy - perpY * sideDist);
    const depAmt2 = displaced * 0.15;

    // Process each deposit center
    for (let depI = 0; depI < 3; depI++) {
      let cx, cy, amount;
      if (depI === 0) { cx = depCX0; cy = depCY0; amount = depAmt0; }
      else if (depI === 1) { cx = depCX1; cy = depCY1; amount = depAmt1; }
      else { cx = depCX2; cy = depCY2; amount = depAmt2; }

      // Fast-path: interior deposits skip the clippedTotal loop
      const isInterior = cx >= interiorMinX && cx <= interiorMaxX &&
                         cy >= interiorMinY && cy <= interiorMaxY;
      let invClipped = 1.0;
      if (!isInterior) {
        let clippedTotal = 0;
        for (let ki = 0; ki < kLen; ki++) {
          const px = cx + gaussDx[ki];
          const py = cy + gaussDy[ki];
          if (px >= 0 && px < W && py >= 0 && py < H) {
            clippedTotal += gaussW[ki];
          }
        }
        if (clippedTotal < 0.001) continue;
        invClipped = 1 / clippedTotal;
      }

      for (let ki = 0; ki < kLen; ki++) {
        const px = cx + gaussDx[ki];
        const py = cy + gaussDy[ki];
        if (px < 0 || px >= W || py < 0 || py >= H) continue;

        const frac = gaussW[ki] * invClipped;
        const cellAmount = amount * frac;
        const cellIdx = py * W + px;
        const destH = sandHeight[cellIdx];
        const totalH = Math.min(destH + cellAmount, 1.5);
        const added = totalH - destH;

        if (added > 0.0001 && totalH > 0.001) {
          sandR[cellIdx] = (sandR[cellIdx] * destH + sR * added) / totalH;
          sandG[cellIdx] = (sandG[cellIdx] * destH + sG * added) / totalH;
          sandB[cellIdx] = (sandB[cellIdx] * destH + sB * added) / totalH;
        }
        sandHeight[cellIdx] = totalH;
      }

      markDirty(cx, cy, depositMarkR);
    }
  }
}

function getSymmetryPoints(x, y, dirX, dirY, perpX, perpY) {
  let pts = [{x, y, dirX, dirY, perpX, perpY}];
  if (mirrorV) {
    const len = pts.length;
    for (let i = 0; i < len; i++) {
      const p = pts[i];
      pts.push({x: W - p.x, y: p.y, dirX: -p.dirX, dirY: p.dirY, perpX: -p.perpX, perpY: p.perpY});
    }
  }
  if (mirrorH) {
    const len = pts.length;
    for (let i = 0; i < len; i++) {
      const p = pts[i];
      pts.push({x: p.x, y: H - p.y, dirX: p.dirX, dirY: -p.dirY, perpX: p.perpX, perpY: -p.perpY});
    }
  }
  if (mirrorD) {
    const hw = W / 2, hh = H / 2;
    const ar = W / H, iar = H / W;
    const len = pts.length;
    for (let i = 0; i < len; i++) {
      const p = pts[i];
      // Normalize to [-1,1], swap, denormalize
      const nx = (p.x - hw) / hw;
      const ny = (p.y - hh) / hh;
      const sx = ny * hw + hw;
      const sy = nx * hh + hh;
      // Transform direction
      let sdx = p.dirY * ar;
      let sdy = p.dirX * iar;
      const dlen = Math.sqrt(sdx * sdx + sdy * sdy);
      if (dlen > 0.0001) { sdx /= dlen; sdy /= dlen; const olen = Math.sqrt(p.dirX * p.dirX + p.dirY * p.dirY); sdx *= olen; sdy *= olen; }
      // Transform perpendicular
      let spx = p.perpY * ar;
      let spy = p.perpX * iar;
      const plen = Math.sqrt(spx * spx + spy * spy);
      if (plen > 0.0001) { spx /= plen; spy /= plen; const olen = Math.sqrt(p.perpX * p.perpX + p.perpY * p.perpY); spx *= olen; spy *= olen; }
      pts.push({x: sx, y: sy, dirX: sdx, dirY: sdy, perpX: spx, perpY: spy});
    }
  }
  // Deduplicate points within 1px
  const deduped = [pts[0]];
  for (let i = 1; i < pts.length; i++) {
    let dup = false;
    for (let j = 0; j < deduped.length; j++) {
      const dx = pts[i].x - deduped[j].x;
      const dy = pts[i].y - deduped[j].y;
      if (dx * dx + dy * dy < 1) { dup = true; break; }
    }
    if (!dup) deduped.push(pts[i]);
  }
  return deduped;
}

function carveRakeSymmetric(x, y, tineRadius, dirX, dirY) {
  if (!mirrorV && !mirrorH && !mirrorD) {
    // Check alignment for non-symmetric case too
    const [px, py] = getPerpAt(x, y);
    carveRake(x, y, tineRadius, dirX, dirY, px, py);
    return;
  }
  const [perpX, perpY] = getPerpAt(x, y);
  const points = getSymmetryPoints(x, y, dirX, dirY, perpX, perpY);
  for (const p of points) {
    carveRake(p.x, p.y, tineRadius, p.dirX, p.dirY, p.perpX, p.perpY);
  }
}

function carveRake(x, y, tineRadius, dirX, dirY, overridePerpX, overridePerpY) {
  const offsets = getRakeTineOffsets(tineRadius);
  const perpX = overridePerpX !== undefined ? overridePerpX : getRakePerp()[0];
  const perpY = overridePerpY !== undefined ? overridePerpY : getRakePerp()[1];

  for (const offset of offsets) {
    const tx = x + perpX * offset;
    const ty = y + perpY * offset;
    carveTine(tx, ty, tineRadius, dirX, dirY);
  }
}

// --- Render timing ---
let carveTimeAccum = 0;
let lastRenderTime = 0;
let lastFrameTs = 0;
let lastFps = 0;

// --- Render (optimization #2: dirty-region, #5: reused ImageData) ---
function render() {
  const renderStart = performance.now();
  const d = imageDataBuf;
  const lightX = -0.7;
  const lightY = -0.7;

  // Cache slider values for this frame
  const lightMul = cached.light;
  const noiseMul = cached.noise;
  const normD = cached.normD;
  const normDW = normD * W;
  const invNormD2 = 1 / (normD * 2);

  // Expand dirty rect by normD+1 for normal sampling neighbors
  const normPad = normD + 1;
  const rMinX = Math.max(0, dirtyMinX - normPad);
  const rMinY = Math.max(0, dirtyMinY - normPad);
  const rMaxX = Math.min(W - 1, dirtyMaxX + normPad);
  const rMaxY = Math.min(H - 1, dirtyMaxY + normPad);

  if (!dirtyEmpty) {
    for (let y = rMinY; y <= rMaxY; y++) {
      const yW = y * W;
      for (let x = rMinX; x <= rMaxX; x++) {
        const idx = yW + x;
        const pi = idx << 2;

        const h = sandHeight[idx];
        const baseR = sandR[idx];
        const baseG = sandG[idx];
        const baseB = sandB[idx];

        let lighting = 1.0;
        if (x >= normD && x < W - normD && y >= normD && y < H - normD) {
          const dhdx = (sandHeight[idx + normD] - sandHeight[idx - normD]) * invNormD2;
          const dhdy = (sandHeight[idx + normDW] - sandHeight[idx - normDW]) * invNormD2;
          const dot = -(dhdx * lightX + dhdy * lightY);
          lighting = 1.0 + dot * lightMul;
        }

        const heightBrightness = 0.82 + 0.18 * (h < 0 ? 0 : h > 2 ? 2 : h);
        const shade = lighting * heightBrightness;
        const noise = noiseMap[idx] * shade * noiseMul;

        // Uint8ClampedArray auto-clamps to [0, 255] — no Math.max/min needed
        d[pi]     = baseR * shade + noise;
        d[pi + 1] = baseG * shade + noise;
        d[pi + 2] = baseB * shade + noise;
        d[pi + 3] = 255;
      }
    }

    // Blit only the dirty region
    const dw = rMaxX - rMinX + 1;
    const dh = rMaxY - rMinY + 1;
    ctx.putImageData(imageData, 0, 0, rMinX, rMinY, dw, dh);
  }

  resetDirty();

  // Draw cursor(s)
  if (onCanvas) {
    ctx.save();
    const tineRadius = cached.tineRadius;
    const offsets = getRakeTineOffsets(tineRadius);
    const [perpX, perpY] = getPerpAt(mouseX, mouseY);

    function drawCursorAt(cx, cy, px, py, strokeAlpha, fillAlpha) {
      ctx.strokeStyle = `rgba(80, 60, 40, ${strokeAlpha})`;
      ctx.fillStyle = `rgba(80, 60, 40, ${fillAlpha})`;
      ctx.lineWidth = 1;
      for (const offset of offsets) {
        const tx = cx + px * offset;
        const ty = cy + py * offset;
        ctx.beginPath();
        ctx.arc(tx, ty, tineRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
      }
      if (offsets.length > 1) {
        ctx.strokeStyle = `rgba(80, 60, 40, ${strokeAlpha * 0.7})`;
        ctx.lineWidth = 2;
        const first = offsets[0];
        const last = offsets[offsets.length - 1];
        ctx.beginPath();
        ctx.moveTo(cx + px * first, cy + py * first);
        ctx.lineTo(cx + px * last, cy + py * last);
        ctx.stroke();
      }
    }

    // Primary cursor
    drawCursorAt(mouseX, mouseY, perpX, perpY, 0.35, 0.2);

    // Mirror ghost cursors
    if (mirrorV || mirrorH || mirrorD) {
      const pts = getSymmetryPoints(mouseX, mouseY, 0, 0, perpX, perpY);
      for (let i = 1; i < pts.length; i++) {
        drawCursorAt(pts[i].x, pts[i].y, pts[i].perpX, pts[i].perpY, 0.15, 0.08);
      }
    }
    ctx.restore();
  }

  // Update performance readout
  const renderEnd = performance.now();
  carveTimeAccum = 0;
}

// --- Stroke handling ---
function strokeTo(x, y) {
  const tineRadius = cached.tineRadius;
  const stepFrac = cached.step;
  const dx = x - lastX;
  const dy = y - lastY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 1) return;

  strokeDX = dx;
  strokeDY = dy;

  const steps = Math.max(1, Math.floor(dist / Math.max(1, tineRadius * stepFrac)));

  const carveStart = performance.now();
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const cx = lastX + dx * t;
    const cy = lastY + dy * t;
    carveRakeSymmetric(cx, cy, tineRadius, strokeDX, strokeDY);
  }
  carveTimeAccum += performance.now() - carveStart;

  lastX = x;
  lastY = y;
}

// --- Cursor dirty helper ---
function markCursorDirty() {
  if (!onCanvas) return;
  const tineRadius = cached.tineRadius;
  const offsets = getRakeTineOffsets(tineRadius);
  const [px, py] = getPerpAt(mouseX, mouseY);

  function markCursorAt(cx, cy, cpx, cpy) {
    for (const offset of offsets) {
      markDirty(cx + cpx * offset, cy + cpy * offset, tineRadius + 2);
    }
  }

  markCursorAt(mouseX, mouseY, px, py);

  if (mirrorV || mirrorH || mirrorD) {
    const pts = getSymmetryPoints(mouseX, mouseY, 0, 0, px, py);
    for (let i = 1; i < pts.length; i++) {
      markCursorAt(pts[i].x, pts[i].y, pts[i].perpX, pts[i].perpY);
    }
  }
}

// Mouse events
canvas.addEventListener('mousedown', (e) => {
  if (e.target !== canvas) return;
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  strokeDX = 0; strokeDY = 0;
  const carveStart = performance.now();
  carveRakeSymmetric(x, y, cached.tineRadius, 0, 0);
  carveTimeAccum += performance.now() - carveStart;
  requestRender();
});

canvas.addEventListener('mousemove', (e) => {
  const [x, y] = getPos(e);
  // Mark old cursor position dirty so it gets repainted clean
  markCursorDirty();
  mouseX = x; mouseY = y;
  onCanvas = true;
  if (drawing) {
    strokeTo(x, y);
  }
  // Mark new cursor position dirty
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  markCursorDirty();
  const step = Math.PI / 4; // 45 degrees
  rakeAngle += (e.deltaY > 0 ? -1 : 1) * step;
  rakeAngle = Math.round(rakeAngle / step) * step;
  markCursorDirty();
  requestRender();
}, { passive: false });

canvas.addEventListener('mouseup', () => { drawing = false; });
canvas.addEventListener('mouseleave', () => {
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});
canvas.addEventListener('mouseenter', () => {
  onCanvas = true;
});

// Touch events
canvas.addEventListener('touchstart', (e) => {
  if (e.target !== canvas) return;
  e.preventDefault();
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  mouseX = x; mouseY = y;
  onCanvas = true;
  strokeDX = 0; strokeDY = 0;
  const carveStart = performance.now();
  carveRakeSymmetric(x, y, cached.tineRadius, 0, 0);
  carveTimeAccum += performance.now() - carveStart;
  requestRender();
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const [x, y] = getPos(e);
  markCursorDirty();
  mouseX = x; mouseY = y;
  if (drawing) {
    strokeTo(x, y);
  }
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});

clearBtn.addEventListener('click', clearSand);

const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');
settingsBtn.addEventListener('click', () => {
  const open = settingsPanel.style.display !== 'none';
  settingsPanel.style.display = open ? 'none' : '';
  settingsBtn.classList.toggle('active', !open);
});

// --- Guide Image Overlay ---
const guideOverlay = document.getElementById('guideOverlay');
const guideUpload = document.getElementById('guideUpload');
const guideBtn = document.getElementById('guideBtn');
const guideOpacity = document.getElementById('guideOpacity');
const guideToggle = document.getElementById('guideToggle');
const guideZoom = document.getElementById('guideZoom');
const guideX = document.getElementById('guideX');
const guideY = document.getElementById('guideY');

guideBtn.addEventListener('click', () => guideUpload.click());

guideUpload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    guideOverlay.src = evt.target.result;
    // If opacity is 0 (default), set it to 50% so the user sees the image immediately
    if (guideOpacity.value === '0') {
      guideOpacity.value = 50;
      guideOverlay.style.opacity = '0.5';
    }
  };
  reader.readAsDataURL(file);
});

guideOpacity.addEventListener('input', () => {
  guideOverlay.style.opacity = guideOpacity.value / 100;
});

guideToggle.addEventListener('change', () => {
  guideOverlay.style.display = guideToggle.checked ? 'block' : 'none';
});

function updateGuideTransform() {
  const scale = guideZoom.value / 100;
  const x = guideX.value;
  const y = guideY.value;
  guideOverlay.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
}

guideZoom.addEventListener('input', updateGuideTransform);
guideX.addEventListener('input', updateGuideTransform);
guideY.addEventListener('input', updateGuideTransform);

// --- Tabs ---
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    tabBtns.forEach(b => b.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});

// --- Mirror toggles ---
const mirrorVBtn = document.getElementById('mirrorVBtn');
const mirrorHBtn = document.getElementById('mirrorHBtn');
const mirrorDBtn = document.getElementById('mirrorDBtn');
const symmetryLines = document.getElementById('symmetryLines');
const symV = document.getElementById('symV');
const symH = document.getElementById('symH');
const symD1 = document.getElementById('symD1');
const symD2 = document.getElementById('symD2');
const symCenter = document.getElementById('symCenter');

function updateSymmetryLines() {
  const any = mirrorV || mirrorH || mirrorD || alignCenter;
  symmetryLines.style.display = any ? '' : 'none';
  symV.style.display = mirrorV ? '' : 'none';
  symH.style.display = mirrorH ? '' : 'none';
  symD1.style.display = mirrorD ? '' : 'none';
  symD2.style.display = mirrorD ? '' : 'none';
  symCenter.style.display = (any) ? '' : 'none';
}

mirrorVBtn.addEventListener('click', () => {
  mirrorV = !mirrorV;
  mirrorVBtn.classList.toggle('active', mirrorV);
  updateSymmetryLines();
  markCursorDirty();
  requestRender();
  saveSettings();
});

mirrorHBtn.addEventListener('click', () => {
  mirrorH = !mirrorH;
  mirrorHBtn.classList.toggle('active', mirrorH);
  updateSymmetryLines();
  markCursorDirty();
  requestRender();
  saveSettings();
});

mirrorDBtn.addEventListener('click', () => {
  mirrorD = !mirrorD;
  mirrorDBtn.classList.toggle('active', mirrorD);
  updateSymmetryLines();
  markCursorDirty();
  requestRender();
  saveSettings();
});

const alignCenterToggle = document.getElementById('alignCenterToggle');
alignCenterToggle.addEventListener('change', () => {
  alignCenter = alignCenterToggle.checked;
  updateSymmetryLines();
  markCursorDirty();
  requestRender();
  saveSettings();
});

// --- Settings Persistence ---
function saveSettings() {
  const settings = {};
  for (const def of SLIDER_CONFIG) {
    settings[def.key] = sliderEls[def.key].el.value;
  }
  settings.guideShow = guideToggle.checked;
  settings.guideOpacity = guideOpacity.value;
  settings.guideZoom = guideZoom.value;
  settings.guideX = guideX.value;
  settings.guideY = guideY.value;
  settings.mirrorV = mirrorV;
  settings.mirrorH = mirrorH;
  settings.mirrorD = mirrorD;
  settings.alignCenter = alignCenter;
  localStorage.setItem('zenGardenSettings', JSON.stringify(settings));
}

function loadSettings() {
  const saved = localStorage.getItem('zenGardenSettings');
  if (!saved) return;
  try {
    const s = JSON.parse(saved);
    for (const def of SLIDER_CONFIG) {
      if (s[def.key] !== undefined) {
        const { el, labelEl } = sliderEls[def.key];
        el.value = s[def.key];
        cached[def.key] = def.parse(el.value);
        if (labelEl) labelEl.textContent = el.value;
      }
    }
    if (s.guideShow !== undefined) guideToggle.checked = s.guideShow;
    if (s.guideOpacity !== undefined) guideOpacity.value = s.guideOpacity;
    if (s.guideZoom !== undefined) guideZoom.value = s.guideZoom;
    if (s.guideX !== undefined) guideX.value = s.guideX;
    if (s.guideY !== undefined) guideY.value = s.guideY;
    guideOverlay.style.display = guideToggle.checked ? 'block' : 'none';
    guideOverlay.style.opacity = guideOpacity.value / 100;
    updateGuideTransform();
    if (s.mirrorV !== undefined) { mirrorV = s.mirrorV; mirrorVBtn.classList.toggle('active', mirrorV); }
    if (s.mirrorH !== undefined) { mirrorH = s.mirrorH; mirrorHBtn.classList.toggle('active', mirrorH); }
    if (s.mirrorD !== undefined) { mirrorD = s.mirrorD; mirrorDBtn.classList.toggle('active', mirrorD); }
    if (s.alignCenter !== undefined) { alignCenter = s.alignCenter; alignCenterToggle.checked = alignCenter; }
    updateSymmetryLines();
  } catch (e) {
    console.warn('Failed to load settings', e);
  }
}

// Add global listener to save on any input change in settings panel
document.getElementById('settingsPanel').addEventListener('input', saveSettings);
document.getElementById('settingsPanel').addEventListener('change', saveSettings); // for checkbox

// --- Init ---
setupSliders();
loadSettings();
rebuildGaussKernel();
clearSand();
</script>
</body>
</html>
