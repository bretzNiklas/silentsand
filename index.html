<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-SCBVJH1HLS"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-SCBVJH1HLS');
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": ["SoftwareApplication", "Game"],
  "name": "Zen Garden Online",
  "url": "https://silentsand.me",
  "description": "A free virtual mindfulness tool that lets you create satisfying sand patterns in a digital Japanese rock garden.",
  "genre": ["Simulation", "Relaxation", "Casual"],
  "applicationCategory": "GameApplication",
  "operatingSystem": "Any",
  "offers": {
    "@type": "Offer",
    "price": "0",
    "priceCurrency": "USD"
  },
  "aggregateRating": {
    "@type": "AggregateRating",
    "ratingValue": "4.8",
    "ratingCount": "120"
  }
}
</script>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zen Garden Online - Virtual Mindfulness & Sand Raking</title>
<meta name="description" content="Experience peace with Zen Garden Online. Create satisfying sand patterns, practice mindfulness, and reduce stress with this free virtual Japanese rock garden simulator.">
<link rel="icon" type="image/png" href="img.png">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    min-height: 100vh;
    overflow-y: auto;
    font-family: 'Segoe UI', system-ui, sans-serif;
    user-select: none;
    padding: 40px 0;
  }
  h1 {
    color: #c2a67d;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    font-size: 20px;
    margin-bottom: 16px;
    opacity: 0.7;
  }
  canvas {
    display: block;
    cursor: none;
    box-shadow: 0 0 60px rgba(0,0,0,0.5);
  }
  .controls {
    margin-top: 16px;
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 800px;
  }
  button {
    background: none;
    border: 1px solid #5a4a35;
    color: #c2a67d;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  button:hover { background: #5a4a35; color: #e8d5b7; }
  button.active { background: #5a4a35; color: #e8d5b7; }

  .size-controls { display: flex; align-items: center; gap: 8px; }
  .size-controls span { color: #c2a67d; font-size: 12px; letter-spacing: 0.1em; font-weight: 500; }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100px;
    height: 3px;
    background: #5a4a35;
    border-radius: 2px;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    background: #c2a67d;
    border-radius: 50%;
    cursor: pointer;
  }
  .tine-controls { display: flex; align-items: center; gap: 8px; }
  .tine-controls span { color: #c2a67d; font-size: 12px; letter-spacing: 0.1em; font-weight: 500; }
  .tine-controls .tine-label { color: #c2a67d; min-width: 8px; text-align: center; }
  .info-i {
    display: inline-flex; align-items: center; justify-content: center;
    width: 13px; height: 13px; border-radius: 50%;
    border: 1px solid #5a4a3566; color: #5a4a3588;
    font-size: 9px; font-style: italic; font-family: Georgia, serif;
    cursor: default; position: relative; flex-shrink: 0;
  }
  .info-i .info-tip {
    display: none; position: absolute; bottom: 20px; left: 50%;
    transform: translateX(-50%); white-space: nowrap;
    background: #2a2218; color: #c2a67dcc; font-style: normal;
    font-family: 'Segoe UI', system-ui, sans-serif;
    font-size: 11px; padding: 4px 8px; border-radius: 4px;
    pointer-events: none; letter-spacing: 0.02em; z-index: 10;
  }
  .info-i:hover .info-tip { display: block; }

  /* Custom Checkbox Toggle */
  .toggle-switch {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 18px;
    margin-left: 4px;
  }
  .toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .toggle-slider {
    position: absolute;
    cursor: pointer;
    top: 0; left: 0; right: 0; bottom: 0;
    background-color: #2a2218;
    border: 1px solid #5a4a35;
    transition: .4s;
    border-radius: 18px;
  }
  .toggle-slider:before {
    position: absolute;
    content: "";
    height: 12px;
    width: 12px;
    left: 2px;
    bottom: 2px;
    background-color: #5a4a35;
    transition: .4s;
    border-radius: 50%;
  }
  input:checked + .toggle-slider {
    background-color: #5a4a35;
  }
  input:checked + .toggle-slider:before {
    transform: translateX(18px);
    background-color: #c2a67d;
  }

  /* Tabs */
  .tabs {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin-bottom: 16px;
    border-bottom: 1px solid #5a4a3544;
  }
  .tab-btn {
    background: none;
    border: none;
    color: #5a4a35;
    padding: 8px 12px;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    cursor: pointer;
    opacity: 0.6;
    transition: all 0.3s;
    border-bottom: 2px solid transparent;
  }
  .tab-btn:hover { opacity: 1; color: #c2a67d; }
  .tab-btn.active {
    opacity: 1;
    color: #c2a67d;
    border-bottom: 2px solid #c2a67d;
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }
</style>
</head>
<body>
<h1>silentsand.me</h1>
<div style="position: relative; display: inline-block; overflow: hidden; border-radius: 6px;">
  <canvas id="garden"></canvas>
  <img id="guideOverlay" src="" alt="" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; object-fit: contain;">
</div>
<div style="width: 100%; max-width: 1120px; margin-top: 16px; padding: 0 20px;">
  <button id="clearBtn" style="width: 100%;">Clear Sand</button>
</div>
<div class="controls" style="margin-top: 16px;">
  <button id="settingsBtn" class="active">Tools</button>
</div>

<div id="settingsPanel" style="margin-top: 16px; padding-top: 8px; border-top: 1px solid #5a4a3544;">
  <div class="tabs">
    <button class="tab-btn active" data-tab="tab-rake">Rake</button>
    <button class="tab-btn" data-tab="tab-guide">Image</button>
    <button class="tab-btn" data-tab="tab-tuning">Tuning</button>
  </div>

  <div id="tab-rake" class="tab-content active">
    <div class="controls">
      <div class="tine-controls">
        <span>Tines</span>
        <input type="range" id="tineSlider" min="1" max="11" step="1" value="6">
        <span class="tine-label" id="tineLabel">6</span>
      </div>
      <div class="size-controls">
        <span>Gap</span>
        <input type="range" id="gapSlider" min="1" max="5" step="0.1" value="3">
      </div>
      <div class="size-controls">
        <span>Size</span>
        <input type="range" id="sizeSlider" min="4" max="20" value="6">
      </div>
    </div>
    <div style="margin-top: 12px; text-align: center;">
      <span style="color: #c2a67d; font-size: 13px; font-weight: 500; opacity: 0.8; letter-spacing: 0.05em;">
        Scroll wheel to rotate rake
      </span>
    </div>
  </div>

  <div id="tab-guide" class="tab-content">
    <div class="controls">
      <input type="file" id="guideUpload" accept="image/*" style="display: none;">
      <button id="guideBtn" style="width: auto;">Upload Guide</button>
      <div class="size-controls">
        <span>Show</span>
        <label class="toggle-switch">
          <input type="checkbox" id="guideToggle" checked>
          <span class="toggle-slider"></span>
        </label>
      </div>
      <div class="size-controls">
        <span>Opacity</span>
        <input type="range" id="guideOpacity" min="0" max="100" value="0">
      </div>
      <div class="size-controls">
        <span>Zoom</span>
        <input type="range" id="guideZoom" min="50" max="300" value="100">
      </div>
    </div>
    <div class="controls" style="margin-top: 8px;">
      <div class="size-controls">
        <span>X</span>
        <input type="range" id="guideX" min="-400" max="400" value="0">
      </div>
      <div class="size-controls">
        <span>Y</span>
        <input type="range" id="guideY" min="-400" max="400" value="0">
      </div>
    </div>
  </div>

  <div id="tab-tuning" class="tab-content">
    <div class="controls">
      <div class="size-controls">
        <span>Depth</span>
        <input type="range" id="dbgDepth" min="0.05" max="0.60" step="0.01" value="0.38">
        <span class="tine-label" id="dbgDepthLabel">0.38</span>
      </div>
      <div class="size-controls">
        <span>Rim</span>
        <input type="range" id="dbgRim" min="0.02" max="0.25" step="0.01" value="0.12">
        <span class="tine-label" id="dbgRimLabel">0.12</span>
      </div>
      <div class="size-controls">
        <span>Light</span>
        <input type="range" id="dbgLight" min="0.10" max="0.80" step="0.01" value="0.40">
        <span class="tine-label" id="dbgLightLabel">0.40</span>
      </div>
      <div class="size-controls">
        <span>Blend</span>
        <input type="range" id="dbgBlend" min="0.20" max="0.80" step="0.01" value="0.55">
        <span class="tine-label" id="dbgBlendLabel">0.55</span>
      </div>
    </div>
    <div class="controls" style="margin-top:8px;">
      <div class="size-controls">
        <span>Step</span>
        <input type="range" id="dbgStep" min="0.03" max="0.50" step="0.01" value="0.22">
        <span class="tine-label" id="dbgStepLabel">0.22</span>
        <span class="info-i">i<span class="info-tip">Stroke density. Higher = faster, coarser</span></span>
      </div>
      <div class="size-controls">
        <span>Spread</span>
        <input type="range" id="dbgSpread" min="1" max="4" step="1" value="1">
        <span class="tine-label" id="dbgSpreadLabel">1</span>
        <span class="info-i">i<span class="info-tip">Sand spread radius. Higher = slower, wider piles</span></span>
      </div>
      <div class="size-controls">
        <span>FwdD</span>
        <input type="range" id="dbgFwdD" min="0.20" max="2.00" step="0.01" value="0.59">
        <span class="tine-label" id="dbgFwdDLabel">0.59</span>
        <span class="info-i">i<span class="info-tip">Forward push distance. Higher = sand thrown further ahead</span></span>
      </div>
      <div class="size-controls">
        <span>SideD</span>
        <input type="range" id="dbgSideD" min="0.10" max="1.50" step="0.01" value="0.66">
        <span class="tine-label" id="dbgSideDLabel">0.66</span>
        <span class="info-i">i<span class="info-tip">Side push distance. Higher = wider rim banks</span></span>
      </div>
      <div class="size-controls">
        <span>NormD</span>
        <input type="range" id="dbgNormD" min="1" max="6" step="1" value="4">
        <span class="tine-label" id="dbgNormDLabel">4</span>
        <span class="info-i">i<span class="info-tip">Lighting sample distance. Higher = smoother, softer shading</span></span>
      </div>
      <div class="size-controls">
        <span>Noise</span>
        <input type="range" id="dbgNoise" min="0.00" max="1.00" step="0.01" value="0.89">
        <span class="tine-label" id="dbgNoiseLabel">0.89</span>
        <span class="info-i">i<span class="info-tip">Sand grain texture. Higher = heavier grain</span></span>
      </div>
    </div>
  </div>
</div>

<div class="seo-content" style="max-width: 800px; margin: 40px auto; padding: 0 20px; color: #c2a67d; opacity: 0.9;">
  <section style="margin-bottom: 40px; text-align: center;">
    <h2 style="font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; font-size: 18px; margin-bottom: 12px; border-bottom: 1px solid #5a4a3544; display: inline-block; padding-bottom: 4px;">About Zen Garden Online</h2>
    <p style="line-height: 1.6; font-size: 15px;">
      <strong>Zen Garden Online</strong> is a free virtual mindfulness tool that lets you create satisfying sand patterns in a digital Japanese rock garden. Designed for <em>stress reduction</em> and meditation, it offers a calming, creative escape directly in your browser. Whether you are looking to practice mindfulness or simply enjoy the <em>Japanese aesthetic</em> of raking sand, this simulator provides a peaceful retreat.
    </p>
  </section>

  <section>
    <h2 style="font-weight: 300; letter-spacing: 0.1em; text-transform: uppercase; font-size: 18px; margin-bottom: 20px; border-bottom: 1px solid #5a4a3544; padding-bottom: 4px;">Frequently Asked Questions</h2>
    
    <article style="margin-bottom: 24px;">
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">How to play a virtual zen garden?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Playing is simple and intuitive. Use your mouse or touchscreen to rake the sand. 
        <strong>Click and drag</strong> to create grooves. You can adjust the <strong>rake size</strong>, <strong>tine count</strong>, and <strong>spacing</strong> using the "Tools" menu. 
        On desktop, use the <strong>scroll wheel</strong> to rotate the rake for precise patterns. The goal is to create flowing, continuous lines that evoke a sense of water or ripples, a core practice in creating a traditional <em>Karesansui</em> (dry landscape) garden.
      </p>
    </article>

    <article style="margin-bottom: 24px;">
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">What are the benefits of digital meditation?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Digital meditation tools like this online zen garden help lower cortisol levels and improve focus. By engaging in a repetitive, creative task (raking sand), you can achieve a "flow state" similar to traditional meditation. It provides a quick mental break, allowing you to reset your mind, reduce anxiety, and return to your tasks with renewed clarity.
      </p>
    </article>

    <article>
      <h3 style="font-size: 16px; font-weight: 500; color: #e8d5b7; margin-bottom: 8px;">Is this Zen Garden free to use?</h3>
      <p style="line-height: 1.6; font-size: 14px; color: #c2a67dcc;">
        Yes, <strong>Zen Garden Online</strong> is completely free and accessible from any modern web browser on desktop or mobile. There are no downloads or installations required to start your mindfulness journey.
      </p>
    </article>
  </section>
</div>

<script>
const canvas = document.getElementById('garden');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('sizeSlider');
const clearBtn = document.getElementById('clearBtn');
const tineSlider = document.getElementById('tineSlider');
const tineLabel = document.getElementById('tineLabel');
const gapSlider = document.getElementById('gapSlider');
const dbgDepth = document.getElementById('dbgDepth');
const dbgDepthLabel = document.getElementById('dbgDepthLabel');
const dbgRim = document.getElementById('dbgRim');
const dbgRimLabel = document.getElementById('dbgRimLabel');
const dbgLight = document.getElementById('dbgLight');
const dbgLightLabel = document.getElementById('dbgLightLabel');
const dbgBlend = document.getElementById('dbgBlend');
const dbgBlendLabel = document.getElementById('dbgBlendLabel');
const dbgStep = document.getElementById('dbgStep');
const dbgStepLabel = document.getElementById('dbgStepLabel');
const dbgSpread = document.getElementById('dbgSpread');
const dbgSpreadLabel = document.getElementById('dbgSpreadLabel');
const dbgFwdD = document.getElementById('dbgFwdD');
const dbgFwdDLabel = document.getElementById('dbgFwdDLabel');
const dbgSideD = document.getElementById('dbgSideD');
const dbgSideDLabel = document.getElementById('dbgSideDLabel');
const dbgNormD = document.getElementById('dbgNormD');
const dbgNormDLabel = document.getElementById('dbgNormDLabel');
const dbgNoise = document.getElementById('dbgNoise');
const dbgNoiseLabel = document.getElementById('dbgNoiseLabel');

// --- Cached slider values (read from DOM once, then updated via events) ---
let cachedTineRadius = parseInt(slider.value);
let cachedTineCount = parseInt(tineSlider.value);
let cachedGapMul = parseFloat(gapSlider.value);
let cachedDepth = parseFloat(dbgDepth.value);
let cachedRim = parseFloat(dbgRim.value);
let cachedLight = parseFloat(dbgLight.value);
let cachedBlend = parseFloat(dbgBlend.value);
let cachedStep = parseFloat(dbgStep.value);
let cachedSpreadR = parseInt(dbgSpread.value);
let cachedFwdD = parseFloat(dbgFwdD.value);
let cachedSideD = parseFloat(dbgSideD.value);
let cachedNormD = parseInt(dbgNormD.value);
let cachedNoise = parseFloat(dbgNoise.value);

const W = Math.min(1120, window.innerWidth - 40);
const H = Math.min(630, window.innerHeight - 120);
canvas.width = W;
canvas.height = H;

// --- Sand color presets ---
const SAND_COLORS = [
  [210, 190, 160], // cream (default)
  [185, 110, 70],  // terracotta
  [100, 75, 55],   // dark brown
  [160, 160, 155]  // grey
];

// --- Data model ---
const totalPixels = W * H;
const sandHeight = new Float32Array(totalPixels);
const sandR = new Float32Array(totalPixels);
const sandG = new Float32Array(totalPixels);
const sandB = new Float32Array(totalPixels);
const noiseMap = new Float32Array(totalPixels);

// --- Reuse ImageData buffer (optimization #5) ---
const imageData = ctx.createImageData(W, H);
const imageDataBuf = imageData.data;

// --- Pre-compute gaussian kernel as flat typed arrays ---
const MAX_KERNEL = 81; // (2*4+1)^2 = max possible entries
let gaussDx = new Int8Array(MAX_KERNEL);
let gaussDy = new Int8Array(MAX_KERNEL);
let gaussW = new Float32Array(MAX_KERNEL);
let gaussLen = 0;
let builtSpreadR = -1;

function rebuildGaussKernel() {
  const r = cachedSpreadR;
  if (r === builtSpreadR) return;
  builtSpreadR = r;
  const sigma = r * 0.75;
  const invTwoSigma2 = 1 / (2 * sigma * sigma);
  let count = 0;
  let total = 0;
  for (let sy = -r; sy <= r; sy++) {
    for (let sx = -r; sx <= r; sx++) {
      const d2 = sx * sx + sy * sy;
      if (d2 > r * r) continue;
      const w = Math.exp(-d2 * invTwoSigma2);
      gaussDx[count] = sx;
      gaussDy[count] = sy;
      gaussW[count] = w;
      total += w;
      count++;
    }
  }
  const invTotal = 1 / total;
  for (let i = 0; i < count; i++) gaussW[i] *= invTotal;
  gaussLen = count;
}
rebuildGaussKernel();

// --- Pre-allocated displacement buffers (optimization #4) ---
const MAX_R = 20;
const MAX_DISP = (2 * MAX_R + 1) * (2 * MAX_R + 1);
const dispIdx = new Int32Array(MAX_DISP);
const dispAmount = new Float32Array(MAX_DISP);
const dispSrcR = new Float32Array(MAX_DISP);
const dispSrcG = new Float32Array(MAX_DISP);
const dispSrcB = new Float32Array(MAX_DISP);

// --- Dirty region tracking (optimization #2) ---
let dirtyMinX = 0, dirtyMinY = 0, dirtyMaxX = W - 1, dirtyMaxY = H - 1;
let dirtyEmpty = false;

function markDirty(x, y, radius) {
  const r = Math.ceil(radius);
  const x0 = Math.max(0, Math.floor(x) - r);
  const y0 = Math.max(0, Math.floor(y) - r);
  const x1 = Math.min(W - 1, Math.ceil(x) + r);
  const y1 = Math.min(H - 1, Math.ceil(y) + r);
  if (dirtyEmpty) {
    dirtyMinX = x0; dirtyMinY = y0;
    dirtyMaxX = x1; dirtyMaxY = y1;
    dirtyEmpty = false;
  } else {
    if (x0 < dirtyMinX) dirtyMinX = x0;
    if (y0 < dirtyMinY) dirtyMinY = y0;
    if (x1 > dirtyMaxX) dirtyMaxX = x1;
    if (y1 > dirtyMaxY) dirtyMaxY = y1;
  }
}

function markFullDirty() {
  dirtyMinX = 0; dirtyMinY = 0;
  dirtyMaxX = W - 1; dirtyMaxY = H - 1;
  dirtyEmpty = false;
}

function resetDirty() {
  dirtyEmpty = true;
}

// --- rAF render coalescing (optimization #1) ---
let renderScheduled = false;
function requestRender() {
  if (!renderScheduled) {
    renderScheduled = true;
    requestAnimationFrame(() => { renderScheduled = false; render(); });
  }
}

function initSand() {
  const def = SAND_COLORS[0];
  for (let i = 0; i < totalPixels; i++) {
    sandHeight[i] = 1.0;
    sandR[i] = def[0];
    sandG[i] = def[1];
    sandB[i] = def[2];
  }
}

function generateNoiseMap() {
  for (let i = 0; i < totalPixels; i++) {
    const fine = (Math.random() - 0.5) * 10;
    const coarse = Math.random() < 0.03 ? (Math.random() - 0.5) * 16 : 0;
    noiseMap[i] = fine + coarse;
  }
}

function clearSand() {
  initSand();
  // Add fine random variation for a natural untouched look
  for (let i = 0; i < totalPixels; i++) {
    sandHeight[i] += (Math.random() - 0.5) * 0.3;
    sandHeight[i] = Math.max(0.1, Math.min(1.5, sandHeight[i]));
  }
  generateNoiseMap();
  markFullDirty();
  requestRender();
}

// --- Tine helpers ---
function getTineCount() {
  return cachedTineCount;
}

function getRakeTineOffsets(tineRadius) {
  const count = cachedTineCount;
  const spacing = cachedGapMul * tineRadius;
  const offsets = [];
  for (let i = 0; i < count; i++) {
    offsets.push((i - (count - 1) / 2) * spacing);
  }
  return offsets;
}

// --- Drawing state ---
let drawing = false;
let lastX = -1, lastY = -1;
let rakeAngle = 0;
let mouseX = -1, mouseY = -1;
let onCanvas = false;
// Track stroke direction for displacement
let strokeDX = 0, strokeDY = 0;

function getRakePerp() {
  return [Math.cos(rakeAngle), Math.sin(rakeAngle)];
}

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  if (e.touches) {
    return [
      (e.touches[0].clientX - rect.left) * scaleX,
      (e.touches[0].clientY - rect.top) * scaleY
    ];
  }
  return [
    (e.clientX - rect.left) * scaleX,
    (e.clientY - rect.top) * scaleY
  ];
}

// --- Pre-computed tine height profile LUT ---
let tineProfileR = -1;
let tineProfileDepth = -1;
let tineProfileRim = -1;
let tineProfile = null; // Float32Array, size (2*r+1)²
let tineProfileStride = 0;

function rebuildTineProfile(r) {
  const curDepth = cachedDepth;
  const curRim = cachedRim;
  if (r === tineProfileR && curDepth === tineProfileDepth && curRim === tineProfileRim) return;
  tineProfileR = r;
  tineProfileDepth = curDepth;
  tineProfileRim = curRim;
  const side = 2 * r + 1;
  tineProfileStride = side;
  tineProfile = new Float32Array(side * side);
  const rSq = r * r;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const dist2 = dx * dx + dy * dy;
      if (dist2 > rSq) {
        tineProfile[(dy + r) * side + (dx + r)] = -1; // sentinel: outside
        continue;
      }
      const t = Math.sqrt(dist2) / r;
      // Smooth groove: cubic ease for the channel, gentle rim
      let h;
      if (t < 0.6) {
        const u = t / 0.6;
        h = 1.0 - curDepth * (1 - u * u * u);
      } else if (t < 0.85) {
        const u = (t - 0.6) / 0.25;
        h = 1.0 + u * curRim;
      } else {
        const u = (t - 0.85) / 0.15;
        h = (1.0 + curRim) - u * curRim;
      }
      tineProfile[(dy + r) * side + (dx + r)] = h;
    }
  }
}

// --- Sand displacement in carveTine (optimizations #4, #6) ---
function carveTine(x, y, radius, dirX, dirY) {
  const r = Math.floor(radius);
  rebuildTineProfile(r);
  const ix = Math.round(x);
  const iy = Math.round(y);

  // Normalize stroke direction
  const dirLenSq = dirX * dirX + dirY * dirY;
  let ndx = 0, ndy = 0;
  if (dirLenSq > 0.000001) {
    const dirLen = Math.sqrt(dirLenSq);
    ndx = dirX / dirLen;
    ndy = dirY / dirLen;
  }
  // Perpendicular (for side displacement)
  const perpX = -ndy;
  const perpY = ndx;

  // Cache blend value and pre-compute inverse
  const blendTarget = cachedBlend;
  const blendInv = 1 - blendTarget;

  // Pass 1: figure out how much sand to remove at each pixel
  let dispCount = 0;

  for (let dy = -r; dy <= r; dy++) {
    const py = iy + dy;
    if (py < 0 || py >= H) continue;
    const rowBase = py * W;
    const profileRowBase = (dy + r) * tineProfileStride + r;
    for (let dx = -r; dx <= r; dx++) {
      const px = ix + dx;
      if (px < 0 || px >= W) continue;

      const targetHeight = tineProfile[profileRowBase + dx];
      if (targetHeight < 0) continue; // outside radius

      const idx = rowBase + px;
      const currentH = sandHeight[idx];

      const blended = currentH * blendInv + targetHeight * blendTarget;
      if (currentH > blended) {
        const displaced = currentH - blended;
        dispIdx[dispCount] = idx;
        dispAmount[dispCount] = displaced;
        dispSrcR[dispCount] = sandR[idx];
        dispSrcG[dispCount] = sandG[idx];
        dispSrcB[dispCount] = sandB[idx];
        dispCount++;
        sandHeight[idx] = blended;
      }
    }
  }

  // Mark the carve area dirty
  markDirty(ix, iy, r + 2);

  // Pass 2: distribute displaced sand using flat gaussian kernel arrays
  const fwdDist = r * cachedFwdD;
  const sideDist = r * cachedSideD;
  const spreadR = cachedSpreadR;
  // Deposit spread radius for dirty marking
  const depositMarkR = spreadR + 2;
  // Interior bounds — if deposit center is inside these, all kernel entries are in-bounds
  const interiorMinX = spreadR;
  const interiorMinY = spreadR;
  const interiorMaxX = W - 1 - spreadR;
  const interiorMaxY = H - 1 - spreadR;
  const kLen = gaussLen;

  for (let i = 0; i < dispCount; i++) {
    const srcIdx = dispIdx[i];
    const displaced = dispAmount[i];
    const sR = dispSrcR[i];
    const sG = dispSrcG[i];
    const sB = dispSrcB[i];
    const srcPx = srcIdx % W;
    const srcPy = (srcIdx - srcPx) / W;

    // 3 deposit centers inlined (forward, sideA, sideB)
    const depCX0 = Math.round(srcPx + ndx * fwdDist);
    const depCY0 = Math.round(srcPy + ndy * fwdDist);
    const depAmt0 = displaced * 0.70;

    const depCX1 = Math.round(srcPx + perpX * sideDist);
    const depCY1 = Math.round(srcPy + perpY * sideDist);
    const depAmt1 = displaced * 0.15;

    const depCX2 = Math.round(srcPx - perpX * sideDist);
    const depCY2 = Math.round(srcPy - perpY * sideDist);
    const depAmt2 = displaced * 0.15;

    // Process each deposit center
    for (let depI = 0; depI < 3; depI++) {
      let cx, cy, amount;
      if (depI === 0) { cx = depCX0; cy = depCY0; amount = depAmt0; }
      else if (depI === 1) { cx = depCX1; cy = depCY1; amount = depAmt1; }
      else { cx = depCX2; cy = depCY2; amount = depAmt2; }

      // Fast-path: interior deposits skip the clippedTotal loop
      const isInterior = cx >= interiorMinX && cx <= interiorMaxX &&
                         cy >= interiorMinY && cy <= interiorMaxY;
      let invClipped = 1.0;
      if (!isInterior) {
        let clippedTotal = 0;
        for (let ki = 0; ki < kLen; ki++) {
          const px = cx + gaussDx[ki];
          const py = cy + gaussDy[ki];
          if (px >= 0 && px < W && py >= 0 && py < H) {
            clippedTotal += gaussW[ki];
          }
        }
        if (clippedTotal < 0.001) continue;
        invClipped = 1 / clippedTotal;
      }

      for (let ki = 0; ki < kLen; ki++) {
        const px = cx + gaussDx[ki];
        const py = cy + gaussDy[ki];
        if (px < 0 || px >= W || py < 0 || py >= H) continue;

        const frac = gaussW[ki] * invClipped;
        const cellAmount = amount * frac;
        const cellIdx = py * W + px;
        const destH = sandHeight[cellIdx];
        const totalH = Math.min(destH + cellAmount, 1.5);
        const added = totalH - destH;

        if (added > 0.0001 && totalH > 0.001) {
          sandR[cellIdx] = (sandR[cellIdx] * destH + sR * added) / totalH;
          sandG[cellIdx] = (sandG[cellIdx] * destH + sG * added) / totalH;
          sandB[cellIdx] = (sandB[cellIdx] * destH + sB * added) / totalH;
        }
        sandHeight[cellIdx] = totalH;
      }

      markDirty(cx, cy, depositMarkR);
    }
  }
}

function carveRake(x, y, tineRadius, dirX, dirY) {
  const offsets = getRakeTineOffsets(tineRadius);
  const [perpX, perpY] = getRakePerp();

  for (const offset of offsets) {
    const tx = x + perpX * offset;
    const ty = y + perpY * offset;
    carveTine(tx, ty, tineRadius, dirX, dirY);
  }
}

// --- Render timing ---
let carveTimeAccum = 0;
let lastRenderTime = 0;
let lastFrameTs = 0;
let lastFps = 0;

// --- Render (optimization #2: dirty-region, #5: reused ImageData) ---
function render() {
  const renderStart = performance.now();
  const d = imageDataBuf;
  const lightX = -0.7;
  const lightY = -0.7;

  // Cache slider values for this frame
  const lightMul = cachedLight;
  const noiseMul = cachedNoise;
  const normD = cachedNormD;
  const normDW = normD * W;
  const invNormD2 = 1 / (normD * 2);

  // Expand dirty rect by normD+1 for normal sampling neighbors
  const normPad = normD + 1;
  const rMinX = Math.max(0, dirtyMinX - normPad);
  const rMinY = Math.max(0, dirtyMinY - normPad);
  const rMaxX = Math.min(W - 1, dirtyMaxX + normPad);
  const rMaxY = Math.min(H - 1, dirtyMaxY + normPad);

  if (!dirtyEmpty) {
    for (let y = rMinY; y <= rMaxY; y++) {
      const yW = y * W;
      for (let x = rMinX; x <= rMaxX; x++) {
        const idx = yW + x;
        const pi = idx << 2;

        const h = sandHeight[idx];
        const baseR = sandR[idx];
        const baseG = sandG[idx];
        const baseB = sandB[idx];

        let lighting = 1.0;
        if (x >= normD && x < W - normD && y >= normD && y < H - normD) {
          const dhdx = (sandHeight[idx + normD] - sandHeight[idx - normD]) * invNormD2;
          const dhdy = (sandHeight[idx + normDW] - sandHeight[idx - normDW]) * invNormD2;
          const dot = -(dhdx * lightX + dhdy * lightY);
          lighting = 1.0 + dot * lightMul;
        }

        const heightBrightness = 0.82 + 0.18 * (h < 0 ? 0 : h > 2 ? 2 : h);
        const shade = lighting * heightBrightness;
        const noise = noiseMap[idx] * shade * noiseMul;

        // Uint8ClampedArray auto-clamps to [0, 255] — no Math.max/min needed
        d[pi]     = baseR * shade + noise;
        d[pi + 1] = baseG * shade + noise;
        d[pi + 2] = baseB * shade + noise;
        d[pi + 3] = 255;
      }
    }

    // Blit only the dirty region
    const dw = rMaxX - rMinX + 1;
    const dh = rMaxY - rMinY + 1;
    ctx.putImageData(imageData, 0, 0, rMinX, rMinY, dw, dh);
  }

  resetDirty();

  // Draw cursor
  if (onCanvas) {
    ctx.save();
    const tineRadius = cachedTineRadius;
    const offsets = getRakeTineOffsets(tineRadius);
    const [perpX, perpY] = getRakePerp();

    ctx.strokeStyle = 'rgba(80, 60, 40, 0.35)';
    ctx.fillStyle = 'rgba(80, 60, 40, 0.2)';
    ctx.lineWidth = 1;

    for (const offset of offsets) {
      const tx = mouseX + perpX * offset;
      const ty = mouseY + perpY * offset;
      ctx.beginPath();
      ctx.arc(tx, ty, tineRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fill();
    }

    if (offsets.length > 1) {
      ctx.strokeStyle = 'rgba(80, 60, 40, 0.25)';
      ctx.lineWidth = 2;
      const first = offsets[0];
      const last = offsets[offsets.length - 1];
      ctx.beginPath();
      ctx.moveTo(mouseX + perpX * first, mouseY + perpY * first);
      ctx.lineTo(mouseX + perpX * last, mouseY + perpY * last);
      ctx.stroke();
    }
    ctx.restore();
  }

  // Update performance readout
  const renderEnd = performance.now();
  carveTimeAccum = 0;
}

// --- Stroke handling ---
function strokeTo(x, y) {
  const tineRadius = cachedTineRadius;
  const stepFrac = cachedStep;
  const dx = x - lastX;
  const dy = y - lastY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 1) return;

  strokeDX = dx;
  strokeDY = dy;

  const steps = Math.max(1, Math.floor(dist / Math.max(1, tineRadius * stepFrac)));

  const carveStart = performance.now();
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const cx = lastX + dx * t;
    const cy = lastY + dy * t;
    carveRake(cx, cy, tineRadius, strokeDX, strokeDY);
  }
  carveTimeAccum += performance.now() - carveStart;

  lastX = x;
  lastY = y;
}

// --- Cursor dirty helper ---
function markCursorDirty() {
  if (!onCanvas) return;
  const tineRadius = cachedTineRadius;
  const offsets = getRakeTineOffsets(tineRadius);
  const [px, py] = getRakePerp();
  for (const offset of offsets) {
    markDirty(mouseX + px * offset, mouseY + py * offset, tineRadius + 2);
  }
}

// --- Event listeners ---
slider.addEventListener('input', () => {
  cachedTineRadius = parseInt(slider.value);
  markCursorDirty();
  requestRender();
});

tineSlider.addEventListener('input', () => {
  cachedTineCount = parseInt(tineSlider.value);
  tineLabel.textContent = tineSlider.value;
  markCursorDirty();
  requestRender();
});

gapSlider.addEventListener('input', () => {
  cachedGapMul = parseFloat(gapSlider.value);
  markCursorDirty();
  requestRender();
});

// Debug slider listeners
dbgDepth.addEventListener('input', () => {
  cachedDepth = parseFloat(dbgDepth.value);
  dbgDepthLabel.textContent = dbgDepth.value;
  tineProfileR = -1; // force profile rebuild
  markFullDirty();
  requestRender();
});
dbgRim.addEventListener('input', () => {
  cachedRim = parseFloat(dbgRim.value);
  dbgRimLabel.textContent = dbgRim.value;
  tineProfileR = -1;
  markFullDirty();
  requestRender();
});
dbgLight.addEventListener('input', () => {
  cachedLight = parseFloat(dbgLight.value);
  dbgLightLabel.textContent = dbgLight.value;
  markFullDirty();
  requestRender();
});
dbgBlend.addEventListener('input', () => {
  cachedBlend = parseFloat(dbgBlend.value);
  dbgBlendLabel.textContent = dbgBlend.value;
});
dbgStep.addEventListener('input', () => {
  cachedStep = parseFloat(dbgStep.value);
  dbgStepLabel.textContent = dbgStep.value;
});
dbgSpread.addEventListener('input', () => {
  cachedSpreadR = parseInt(dbgSpread.value);
  dbgSpreadLabel.textContent = dbgSpread.value;
  rebuildGaussKernel();
});
dbgFwdD.addEventListener('input', () => {
  cachedFwdD = parseFloat(dbgFwdD.value);
  dbgFwdDLabel.textContent = dbgFwdD.value;
});
dbgSideD.addEventListener('input', () => {
  cachedSideD = parseFloat(dbgSideD.value);
  dbgSideDLabel.textContent = dbgSideD.value;
});
dbgNormD.addEventListener('input', () => {
  cachedNormD = parseInt(dbgNormD.value);
  dbgNormDLabel.textContent = dbgNormD.value;
  markFullDirty();
  requestRender();
});
dbgNoise.addEventListener('input', () => {
  cachedNoise = parseFloat(dbgNoise.value);
  dbgNoiseLabel.textContent = dbgNoise.value;
  markFullDirty();
  requestRender();
});

// Mouse events
canvas.addEventListener('mousedown', (e) => {
  if (e.target !== canvas) return;
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  strokeDX = 0; strokeDY = 0;
  const carveStart = performance.now();
  carveRake(x, y, cachedTineRadius, 0, 0);
  carveTimeAccum += performance.now() - carveStart;
  requestRender();
});

canvas.addEventListener('mousemove', (e) => {
  const [x, y] = getPos(e);
  // Mark old cursor position dirty so it gets repainted clean
  markCursorDirty();
  mouseX = x; mouseY = y;
  onCanvas = true;
  if (drawing) {
    strokeTo(x, y);
  }
  // Mark new cursor position dirty
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  markCursorDirty();
  const step = Math.PI / 4; // 45 degrees
  rakeAngle += (e.deltaY > 0 ? -1 : 1) * step;
  rakeAngle = Math.round(rakeAngle / step) * step;
  markCursorDirty();
  requestRender();
}, { passive: false });

canvas.addEventListener('mouseup', () => { drawing = false; });
canvas.addEventListener('mouseleave', () => {
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});
canvas.addEventListener('mouseenter', () => {
  onCanvas = true;
});

// Touch events
canvas.addEventListener('touchstart', (e) => {
  if (e.target !== canvas) return;
  e.preventDefault();
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  mouseX = x; mouseY = y;
  onCanvas = true;
  strokeDX = 0; strokeDY = 0;
  const carveStart = performance.now();
  carveRake(x, y, cachedTineRadius, 0, 0);
  carveTimeAccum += performance.now() - carveStart;
  requestRender();
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const [x, y] = getPos(e);
  markCursorDirty();
  mouseX = x; mouseY = y;
  if (drawing) {
    strokeTo(x, y);
  }
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});

clearBtn.addEventListener('click', clearSand);

const settingsBtn = document.getElementById('settingsBtn');
const settingsPanel = document.getElementById('settingsPanel');
settingsBtn.addEventListener('click', () => {
  const open = settingsPanel.style.display !== 'none';
  settingsPanel.style.display = open ? 'none' : '';
  settingsBtn.classList.toggle('active', !open);
});

// --- Guide Image Overlay ---
const guideOverlay = document.getElementById('guideOverlay');
const guideUpload = document.getElementById('guideUpload');
const guideBtn = document.getElementById('guideBtn');
const guideOpacity = document.getElementById('guideOpacity');
const guideToggle = document.getElementById('guideToggle');
const guideZoom = document.getElementById('guideZoom');
const guideX = document.getElementById('guideX');
const guideY = document.getElementById('guideY');

guideBtn.addEventListener('click', () => guideUpload.click());

guideUpload.addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (evt) => {
    guideOverlay.src = evt.target.result;
    // If opacity is 0 (default), set it to 50% so the user sees the image immediately
    if (guideOpacity.value === '0') {
      guideOpacity.value = 50;
      guideOverlay.style.opacity = '0.5';
    }
  };
  reader.readAsDataURL(file);
});

guideOpacity.addEventListener('input', () => {
  guideOverlay.style.opacity = guideOpacity.value / 100;
});

guideToggle.addEventListener('change', () => {
  guideOverlay.style.display = guideToggle.checked ? 'block' : 'none';
});

function updateGuideTransform() {
  const scale = guideZoom.value / 100;
  const x = guideX.value;
  const y = guideY.value;
  guideOverlay.style.transform = `translate(${x}px, ${y}px) scale(${scale})`;
}

guideZoom.addEventListener('input', updateGuideTransform);
guideX.addEventListener('input', updateGuideTransform);
guideY.addEventListener('input', updateGuideTransform);

// --- Tabs ---
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    tabBtns.forEach(b => b.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});

// --- Settings Persistence ---
function saveSettings() {
  const settings = {
    tineRadius: slider.value,
    tineCount: tineSlider.value,
    gapMul: gapSlider.value,
    depth: dbgDepth.value,
    rim: dbgRim.value,
    light: dbgLight.value,
    blend: dbgBlend.value,
    step: dbgStep.value,
    spread: dbgSpread.value,
    fwdD: dbgFwdD.value,
    sideD: dbgSideD.value,
    normD: dbgNormD.value,
    noise: dbgNoise.value,
    guideShow: guideToggle.checked,
    guideOpacity: guideOpacity.value,
    guideZoom: guideZoom.value,
    guideX: guideX.value,
    guideY: guideY.value
  };
  localStorage.setItem('zenGardenSettings', JSON.stringify(settings));
}

function loadSettings() {
  const saved = localStorage.getItem('zenGardenSettings');
  if (!saved) return;
  try {
    const s = JSON.parse(saved);
    if (s.tineRadius) slider.value = s.tineRadius;
    if (s.tineCount) tineSlider.value = s.tineCount;
    if (s.gapMul) gapSlider.value = s.gapMul;
    if (s.depth) dbgDepth.value = s.depth;
    if (s.rim) dbgRim.value = s.rim;
    if (s.light) dbgLight.value = s.light;
    if (s.blend) dbgBlend.value = s.blend;
    if (s.step) dbgStep.value = s.step;
    if (s.spread) dbgSpread.value = s.spread;
    if (s.fwdD) dbgFwdD.value = s.fwdD;
    if (s.sideD) dbgSideD.value = s.sideD;
    if (s.normD) dbgNormD.value = s.normD;
    if (s.noise) dbgNoise.value = s.noise;
    
    if (s.guideShow !== undefined) guideToggle.checked = s.guideShow;
    if (s.guideOpacity) guideOpacity.value = s.guideOpacity;
    if (s.guideZoom) guideZoom.value = s.guideZoom;
    if (s.guideX) guideX.value = s.guideX;
    if (s.guideY) guideY.value = s.guideY;

    // Apply guide settings visual state
    guideOverlay.style.display = guideToggle.checked ? 'block' : 'none';
    guideOverlay.style.opacity = guideOpacity.value / 100;
    updateGuideTransform();
  } catch (e) {
    console.warn('Failed to load settings', e);
  }
}

// Add global listener to save on any input change in settings panel
document.getElementById('settingsPanel').addEventListener('input', saveSettings);
document.getElementById('settingsPanel').addEventListener('change', saveSettings); // for checkbox

// --- Init ---
// Force sliders to their HTML default values (override browser autofill)
document.querySelectorAll('input[type="range"]').forEach(el => {
  el.value = el.getAttribute('value');
});

loadSettings(); // Override defaults with saved values

// Re-read cached values from the now-correct sliders
cachedTineRadius = parseInt(slider.value);
cachedTineCount = parseInt(tineSlider.value);
cachedGapMul = parseFloat(gapSlider.value);
cachedDepth = parseFloat(dbgDepth.value);
cachedRim = parseFloat(dbgRim.value);
cachedLight = parseFloat(dbgLight.value);
cachedBlend = parseFloat(dbgBlend.value);
cachedStep = parseFloat(dbgStep.value);
cachedSpreadR = parseInt(dbgSpread.value);
cachedFwdD = parseFloat(dbgFwdD.value);
cachedSideD = parseFloat(dbgSideD.value);
cachedNormD = parseInt(dbgNormD.value);
cachedNoise = parseFloat(dbgNoise.value);
// Sync labels
tineLabel.textContent = tineSlider.value;
dbgDepthLabel.textContent = dbgDepth.value;
dbgRimLabel.textContent = dbgRim.value;
dbgLightLabel.textContent = dbgLight.value;
dbgBlendLabel.textContent = dbgBlend.value;
dbgStepLabel.textContent = dbgStep.value;
dbgSpreadLabel.textContent = dbgSpread.value;
dbgFwdDLabel.textContent = dbgFwdD.value;
dbgSideDLabel.textContent = dbgSideD.value;
dbgNormDLabel.textContent = dbgNormD.value;
dbgNoiseLabel.textContent = dbgNoise.value;
rebuildGaussKernel();
clearSand();
</script>
</body>
</html>
