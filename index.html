<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Zen Garden</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #1a1a1a;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Segoe UI', system-ui, sans-serif;
    user-select: none;
  }
  h1 {
    color: #c2a67d;
    font-weight: 300;
    letter-spacing: 0.3em;
    text-transform: uppercase;
    font-size: 14px;
    margin-bottom: 16px;
    opacity: 0.7;
  }
  canvas {
    border-radius: 6px;
    cursor: none;
    box-shadow: 0 0 60px rgba(0,0,0,0.5);
  }
  .controls {
    margin-top: 16px;
    display: flex;
    gap: 16px;
    align-items: center;
    flex-wrap: wrap;
    justify-content: center;
    max-width: 800px;
  }
  button {
    background: none;
    border: 1px solid #5a4a35;
    color: #c2a67d;
    padding: 6px 18px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 12px;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    transition: all 0.3s;
  }
  button:hover { background: #5a4a35; color: #e8d5b7; }
  button.active { background: #5a4a35; color: #e8d5b7; }
  .size-controls { display: flex; align-items: center; gap: 8px; }
  .size-controls span { color: #5a4a3588; font-size: 12px; letter-spacing: 0.1em; }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100px;
    height: 3px;
    background: #5a4a35;
    border-radius: 2px;
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 12px; height: 12px;
    background: #c2a67d;
    border-radius: 50%;
    cursor: pointer;
  }
  .tine-controls { display: flex; align-items: center; gap: 8px; }
  .tine-controls span { color: #5a4a3588; font-size: 12px; letter-spacing: 0.1em; }
  .tine-controls .tine-label { color: #c2a67d; min-width: 8px; text-align: center; }
  .color-swatches { display: flex; gap: 6px; align-items: center; }
  .color-swatches span { color: #5a4a3588; font-size: 12px; letter-spacing: 0.1em; }
  .swatch {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    cursor: pointer;
    border: 2px solid transparent;
    transition: border-color 0.2s, transform 0.2s;
  }
  .swatch:hover { transform: scale(1.15); }
  .swatch.selected { border-color: #e8d5b7; }
</style>
</head>
<body>
<h1>Zen Garden</h1>
<canvas id="garden"></canvas>
<div class="controls">
  <button id="modeBtn" class="active">Rake</button>
  <div class="tine-controls">
    <span>Tines</span>
    <input type="range" id="tineSlider" min="1" max="4" step="1" value="3">
    <span class="tine-label" id="tineLabel">3</span>
  </div>
  <div class="size-controls">
    <span>Gap</span>
    <input type="range" id="gapSlider" min="1" max="5" step="0.1" value="2.5">
  </div>
  <div class="size-controls">
    <span>Size</span>
    <input type="range" id="sizeSlider" min="4" max="20" value="12">
  </div>
  <div class="color-swatches">
    <span>Sand</span>
    <div class="swatch selected" data-color="0" style="background: rgb(210,190,160);" title="Cream"></div>
    <div class="swatch" data-color="1" style="background: rgb(185,110,70);" title="Terracotta"></div>
    <div class="swatch" data-color="2" style="background: rgb(100,75,55);" title="Dark Brown"></div>
    <div class="swatch" data-color="3" style="background: rgb(160,160,155);" title="Grey"></div>
  </div>
  <button id="clearBtn">Clear Sand</button>
</div>
<div style="margin-top:10px;color:#5a4a3544;font-size:11px;letter-spacing:0.1em;">scroll wheel to rotate rake</div>

<script>
const canvas = document.getElementById('garden');
const ctx = canvas.getContext('2d');
const slider = document.getElementById('sizeSlider');
const clearBtn = document.getElementById('clearBtn');
const tineSlider = document.getElementById('tineSlider');
const tineLabel = document.getElementById('tineLabel');
const gapSlider = document.getElementById('gapSlider');
const modeBtn = document.getElementById('modeBtn');

const W = Math.min(800, window.innerWidth - 40);
const H = Math.min(600, window.innerHeight - 120);
canvas.width = W;
canvas.height = H;

// --- Sand color presets ---
const SAND_COLORS = [
  [210, 190, 160], // cream (default)
  [185, 110, 70],  // terracotta
  [100, 75, 55],   // dark brown
  [160, 160, 155]  // grey
];

// --- Mode state ---
let mode = 'rake'; // 'rake' or 'pour'
let selectedColor = 0;

// --- Data model ---
const totalPixels = W * H;
const sandHeight = new Float32Array(totalPixels);
const sandR = new Float32Array(totalPixels);
const sandG = new Float32Array(totalPixels);
const sandB = new Float32Array(totalPixels);
const noiseMap = new Float32Array(totalPixels);

// --- Reuse ImageData buffer (optimization #5) ---
const imageData = ctx.createImageData(W, H);
const imageDataBuf = imageData.data;

// --- Pre-compute gaussian kernel (optimization #3) ---
const SPREAD_R = 2;
const SPREAD_SIGMA = 1.5;
const gaussKernel = []; // [{dx, dy, w}, ...]
let gaussTotal = 0;
for (let sy = -SPREAD_R; sy <= SPREAD_R; sy++) {
  for (let sx = -SPREAD_R; sx <= SPREAD_R; sx++) {
    if (sx * sx + sy * sy > SPREAD_R * SPREAD_R) continue;
    const w = Math.exp(-(sx * sx + sy * sy) / (2 * SPREAD_SIGMA * SPREAD_SIGMA));
    gaussKernel.push({ dx: sx, dy: sy, w });
    gaussTotal += w;
  }
}
for (const k of gaussKernel) k.w /= gaussTotal;

// --- Pre-allocated displacement buffers (optimization #4) ---
const MAX_R = 20;
const MAX_DISP = (2 * MAX_R + 1) * (2 * MAX_R + 1);
const dispIdx = new Int32Array(MAX_DISP);
const dispAmount = new Float32Array(MAX_DISP);
const dispSrcR = new Float32Array(MAX_DISP);
const dispSrcG = new Float32Array(MAX_DISP);
const dispSrcB = new Float32Array(MAX_DISP);

// --- Dirty region tracking (optimization #2) ---
let dirtyMinX = 0, dirtyMinY = 0, dirtyMaxX = W - 1, dirtyMaxY = H - 1;
let dirtyEmpty = false;

function markDirty(x, y, radius) {
  const r = Math.ceil(radius);
  const x0 = Math.max(0, Math.floor(x) - r);
  const y0 = Math.max(0, Math.floor(y) - r);
  const x1 = Math.min(W - 1, Math.ceil(x) + r);
  const y1 = Math.min(H - 1, Math.ceil(y) + r);
  if (dirtyEmpty) {
    dirtyMinX = x0; dirtyMinY = y0;
    dirtyMaxX = x1; dirtyMaxY = y1;
    dirtyEmpty = false;
  } else {
    if (x0 < dirtyMinX) dirtyMinX = x0;
    if (y0 < dirtyMinY) dirtyMinY = y0;
    if (x1 > dirtyMaxX) dirtyMaxX = x1;
    if (y1 > dirtyMaxY) dirtyMaxY = y1;
  }
}

function markFullDirty() {
  dirtyMinX = 0; dirtyMinY = 0;
  dirtyMaxX = W - 1; dirtyMaxY = H - 1;
  dirtyEmpty = false;
}

function resetDirty() {
  dirtyEmpty = true;
}

// --- rAF render coalescing (optimization #1) ---
let renderScheduled = false;
function requestRender() {
  if (!renderScheduled) {
    renderScheduled = true;
    requestAnimationFrame(() => { renderScheduled = false; render(); });
  }
}

function initSand() {
  const def = SAND_COLORS[0];
  for (let i = 0; i < totalPixels; i++) {
    sandHeight[i] = 1.0;
    sandR[i] = def[0];
    sandG[i] = def[1];
    sandB[i] = def[2];
  }
}

function generateNoiseMap() {
  for (let i = 0; i < totalPixels; i++) {
    const fine = (Math.random() - 0.5) * 10;
    const coarse = Math.random() < 0.03 ? (Math.random() - 0.5) * 16 : 0;
    noiseMap[i] = fine + coarse;
  }
}

function clearSand() {
  initSand();
  generateNoiseMap();
  markFullDirty();
  requestRender();
}

// --- Tine helpers ---
function getTineCount() {
  return parseInt(tineSlider.value);
}

function getRakeTineOffsets(tineRadius) {
  const count = getTineCount();
  const spacing = parseFloat(gapSlider.value) * tineRadius;
  const offsets = [];
  for (let i = 0; i < count; i++) {
    offsets.push((i - (count - 1) / 2) * spacing);
  }
  return offsets;
}

// --- Drawing state ---
let drawing = false;
let lastX = -1, lastY = -1;
let rakeAngle = 0;
let mouseX = -1, mouseY = -1;
let onCanvas = false;
// Track stroke direction for displacement
let strokeDX = 0, strokeDY = 0;

function getRakePerp() {
  return [Math.cos(rakeAngle), Math.sin(rakeAngle)];
}

function getPos(e) {
  const rect = canvas.getBoundingClientRect();
  const scaleX = W / rect.width;
  const scaleY = H / rect.height;
  if (e.touches) {
    return [
      (e.touches[0].clientX - rect.left) * scaleX,
      (e.touches[0].clientY - rect.top) * scaleY
    ];
  }
  return [
    (e.clientX - rect.left) * scaleX,
    (e.clientY - rect.top) * scaleY
  ];
}

// --- Pre-computed tine height profile LUT ---
let tineProfileR = -1;
let tineProfile = null; // Float32Array, size (2*r+1)²
let tineProfileStride = 0;

function rebuildTineProfile(r) {
  if (r === tineProfileR) return;
  tineProfileR = r;
  const side = 2 * r + 1;
  tineProfileStride = side;
  tineProfile = new Float32Array(side * side);
  const rSq = r * r;
  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const dist2 = dx * dx + dy * dy;
      if (dist2 > rSq) {
        tineProfile[(dy + r) * side + (dx + r)] = -1; // sentinel: outside
        continue;
      }
      const t = Math.sqrt(dist2) / r;
      let h;
      if (t < 0.65) {
        h = 1.0 - 0.45 * (1 - (t / 0.65) * (t / 0.65));
      } else {
        const edgeT = (t - 0.65) / 0.35;
        h = 1.0 + 0.10 * Math.sin(edgeT * Math.PI);
      }
      tineProfile[(dy + r) * side + (dx + r)] = h;
    }
  }
}

// --- Sand displacement in carveTine (optimizations #4, #6) ---
function carveTine(x, y, radius, dirX, dirY) {
  const r = Math.floor(radius);
  rebuildTineProfile(r);
  const ix = Math.round(x);
  const iy = Math.round(y);

  // Normalize stroke direction
  const dirLenSq = dirX * dirX + dirY * dirY;
  let ndx = 0, ndy = 0;
  if (dirLenSq > 0.000001) {
    const dirLen = Math.sqrt(dirLenSq);
    ndx = dirX / dirLen;
    ndy = dirY / dirLen;
  }
  // Perpendicular (for side displacement)
  const perpX = -ndy;
  const perpY = ndx;

  // Pass 1: figure out how much sand to remove at each pixel
  let dispCount = 0;

  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const px = ix + dx;
      const py = iy + dy;
      if (px < 0 || px >= W || py < 0 || py >= H) continue;

      const targetHeight = tineProfile[(dy + r) * tineProfileStride + (dx + r)];
      if (targetHeight < 0) continue; // outside radius

      const idx = py * W + px;
      const currentH = sandHeight[idx];

      const blended = currentH * 0.3 + targetHeight * 0.7;
      if (currentH > blended) {
        const displaced = currentH - blended;
        dispIdx[dispCount] = idx;
        dispAmount[dispCount] = displaced;
        dispSrcR[dispCount] = sandR[idx];
        dispSrcG[dispCount] = sandG[idx];
        dispSrcB[dispCount] = sandB[idx];
        dispCount++;
        sandHeight[idx] = blended;
      } else {
        sandHeight[idx] = blended;
      }
    }
  }

  // Mark the carve area dirty
  markDirty(ix, iy, r + 2);

  // Pass 2: distribute displaced sand using pre-computed gaussian kernel
  const fwdDist = r * 1.2;
  const sideDist = r * 0.9;
  // Deposit spread radius for dirty marking
  const depositMarkR = SPREAD_R + 2;
  // Interior bounds — if deposit center is inside these, all kernel entries are in-bounds
  const interiorMinX = SPREAD_R;
  const interiorMinY = SPREAD_R;
  const interiorMaxX = W - 1 - SPREAD_R;
  const interiorMaxY = H - 1 - SPREAD_R;

  for (let i = 0; i < dispCount; i++) {
    const srcIdx = dispIdx[i];
    const displaced = dispAmount[i];
    const sR = dispSrcR[i];
    const sG = dispSrcG[i];
    const sB = dispSrcB[i];
    const srcPx = srcIdx % W;
    const srcPy = (srcIdx - srcPx) / W;

    // 3 deposit centers inlined (forward, sideA, sideB)
    const depCX0 = Math.round(srcPx + ndx * fwdDist);
    const depCY0 = Math.round(srcPy + ndy * fwdDist);
    const depAmt0 = displaced * 0.70;

    const depCX1 = Math.round(srcPx + perpX * sideDist);
    const depCY1 = Math.round(srcPy + perpY * sideDist);
    const depAmt1 = displaced * 0.15;

    const depCX2 = Math.round(srcPx - perpX * sideDist);
    const depCY2 = Math.round(srcPy - perpY * sideDist);
    const depAmt2 = displaced * 0.15;

    // Process each deposit center
    for (let depI = 0; depI < 3; depI++) {
      let cx, cy, amount;
      if (depI === 0) { cx = depCX0; cy = depCY0; amount = depAmt0; }
      else if (depI === 1) { cx = depCX1; cy = depCY1; amount = depAmt1; }
      else { cx = depCX2; cy = depCY2; amount = depAmt2; }

      // Fast-path: interior deposits skip the clippedTotal loop
      const isInterior = cx >= interiorMinX && cx <= interiorMaxX &&
                         cy >= interiorMinY && cy <= interiorMaxY;
      let invClipped = 1.0;
      if (!isInterior) {
        let clippedTotal = 0;
        for (let ki = 0; ki < gaussKernel.length; ki++) {
          const gk = gaussKernel[ki];
          const px = cx + gk.dx;
          const py = cy + gk.dy;
          if (px >= 0 && px < W && py >= 0 && py < H) {
            clippedTotal += gk.w;
          }
        }
        if (clippedTotal < 0.001) continue;
        invClipped = 1 / clippedTotal;
      }

      for (let ki = 0; ki < gaussKernel.length; ki++) {
        const gk = gaussKernel[ki];
        const px = cx + gk.dx;
        const py = cy + gk.dy;
        if (px < 0 || px >= W || py < 0 || py >= H) continue;

        const frac = gk.w * invClipped;
        const cellAmount = amount * frac;
        const cellIdx = py * W + px;
        const destH = sandHeight[cellIdx];
        const totalH = Math.min(destH + cellAmount, 1.5);
        const added = totalH - destH;

        if (added > 0.0001 && totalH > 0.001) {
          sandR[cellIdx] = (sandR[cellIdx] * destH + sR * added) / totalH;
          sandG[cellIdx] = (sandG[cellIdx] * destH + sG * added) / totalH;
          sandB[cellIdx] = (sandB[cellIdx] * destH + sB * added) / totalH;
        }
        sandHeight[cellIdx] = totalH;
      }

      markDirty(cx, cy, depositMarkR);
    }
  }
}

function carveRake(x, y, tineRadius, dirX, dirY) {
  const offsets = getRakeTineOffsets(tineRadius);
  const [perpX, perpY] = getRakePerp();

  for (const offset of offsets) {
    const tx = x + perpX * offset;
    const ty = y + perpY * offset;
    carveTine(tx, ty, tineRadius, dirX, dirY);
  }
}

// --- Pour tool (optimization #6: sqrt -> squared comparison) ---
function pourSand(x, y, radius) {
  const r = Math.floor(radius);
  const rSq = r * r;
  const ix = Math.round(x);
  const iy = Math.round(y);
  const col = SAND_COLORS[selectedColor];

  for (let dy = -r; dy <= r; dy++) {
    for (let dx = -r; dx <= r; dx++) {
      const px = ix + dx;
      const py = iy + dy;
      if (px < 0 || px >= W || py < 0 || py >= H) continue;

      const dist2 = dx * dx + dy * dy;
      if (dist2 > rSq) continue;

      const dist = Math.sqrt(dist2);
      const t = 1 - dist / r;
      const amount = 0.04 * t * t;
      const idx = py * W + px;
      const destH = sandHeight[idx];
      const totalH = destH + amount;

      if (totalH > 0.001) {
        sandR[idx] = (sandR[idx] * destH + col[0] * amount) / totalH;
        sandG[idx] = (sandG[idx] * destH + col[1] * amount) / totalH;
        sandB[idx] = (sandB[idx] * destH + col[2] * amount) / totalH;
      }
      sandHeight[idx] = totalH;
    }
  }

  markDirty(ix, iy, r + 2);
}

// --- Render (optimization #2: dirty-region, #5: reused ImageData) ---
function render() {
  const d = imageDataBuf;
  const lightX = -0.7;
  const lightY = -0.7;

  // Expand dirty rect by 2 for normal sampling neighbors
  const rMinX = Math.max(0, dirtyMinX - 2);
  const rMinY = Math.max(0, dirtyMinY - 2);
  const rMaxX = Math.min(W - 1, dirtyMaxX + 2);
  const rMaxY = Math.min(H - 1, dirtyMaxY + 2);

  if (!dirtyEmpty) {
    for (let y = rMinY; y <= rMaxY; y++) {
      for (let x = rMinX; x <= rMaxX; x++) {
        const idx = y * W + x;
        const pi = idx * 4;

        const h = sandHeight[idx];
        const baseR = sandR[idx];
        const baseG = sandG[idx];
        const baseB = sandB[idx];

        let lighting = 1.0;
        if (x > 1 && x < W - 2 && y > 1 && y < H - 2) {
          const dhdx = (sandHeight[idx + 2] - sandHeight[idx - 2]) * 0.25;
          const dhdy = (sandHeight[idx + 2 * W] - sandHeight[idx - 2 * W]) * 0.25;
          const dot = -(dhdx * lightX + dhdy * lightY);
          lighting = 1.0 + dot * 0.3;
        }

        const heightBrightness = 0.85 + 0.15 * Math.min(Math.max(h, 0), 2);
        const shade = lighting * heightBrightness;
        const noise = noiseMap[idx] * shade * 0.45;

        d[pi]     = Math.max(0, Math.min(255, baseR * shade + noise));
        d[pi + 1] = Math.max(0, Math.min(255, baseG * shade + noise));
        d[pi + 2] = Math.max(0, Math.min(255, baseB * shade + noise));
        d[pi + 3] = 255;
      }
    }

    // Blit only the dirty region
    const dw = rMaxX - rMinX + 1;
    const dh = rMaxY - rMinY + 1;
    ctx.putImageData(imageData, 0, 0, rMinX, rMinY, dw, dh);
  } else {
    // Nothing changed — just redraw cursor overlay on top of existing canvas
    // Re-blit only the cursor area to clear previous cursor
    // (full putImageData skipped since nothing is dirty)
  }

  resetDirty();

  // Draw cursor
  if (onCanvas) {
    ctx.save();
    if (mode === 'rake') {
      const tineRadius = parseInt(slider.value);
      const offsets = getRakeTineOffsets(tineRadius);
      const [perpX, perpY] = getRakePerp();

      ctx.strokeStyle = 'rgba(80, 60, 40, 0.35)';
      ctx.fillStyle = 'rgba(80, 60, 40, 0.2)';
      ctx.lineWidth = 1;

      for (const offset of offsets) {
        const tx = mouseX + perpX * offset;
        const ty = mouseY + perpY * offset;
        ctx.beginPath();
        ctx.arc(tx, ty, tineRadius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.fill();
      }

      if (offsets.length > 1) {
        ctx.strokeStyle = 'rgba(80, 60, 40, 0.25)';
        ctx.lineWidth = 2;
        const first = offsets[0];
        const last = offsets[offsets.length - 1];
        ctx.beginPath();
        ctx.moveTo(mouseX + perpX * first, mouseY + perpY * first);
        ctx.lineTo(mouseX + perpX * last, mouseY + perpY * last);
        ctx.stroke();
      }
    } else {
      const pourRadius = parseInt(slider.value);
      const col = SAND_COLORS[selectedColor];
      ctx.strokeStyle = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 0.7)`;
      ctx.fillStyle = `rgba(${col[0]}, ${col[1]}, ${col[2]}, 0.15)`;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(mouseX, mouseY, pourRadius, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fill();
    }
    ctx.restore();
  }
}

// --- Stroke handling ---
function strokeTo(x, y) {
  const tineRadius = parseInt(slider.value);
  const dx = x - lastX;
  const dy = y - lastY;
  const dist = Math.sqrt(dx * dx + dy * dy);
  if (dist < 1) return;

  strokeDX = dx;
  strokeDY = dy;

  const steps = Math.max(1, Math.floor(dist / Math.max(3, tineRadius * 0.4)));

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const cx = lastX + dx * t;
    const cy = lastY + dy * t;
    if (mode === 'rake') {
      carveRake(cx, cy, tineRadius, strokeDX, strokeDY);
    } else {
      pourSand(cx, cy, tineRadius);
    }
  }

  lastX = x;
  lastY = y;
}

// --- Cursor dirty helper ---
function markCursorDirty() {
  if (!onCanvas) return;
  const tineRadius = parseInt(slider.value);
  if (mode === 'rake') {
    const offsets = getRakeTineOffsets(tineRadius);
    const [px, py] = getRakePerp();
    for (const offset of offsets) {
      markDirty(mouseX + px * offset, mouseY + py * offset, tineRadius + 2);
    }
  } else {
    markDirty(mouseX, mouseY, tineRadius + 2);
  }
}

// --- Event listeners ---
tineSlider.addEventListener('input', () => {
  tineLabel.textContent = tineSlider.value;
  markCursorDirty();
  requestRender();
});

gapSlider.addEventListener('input', () => {
  markCursorDirty();
  requestRender();
});

// Mouse events
canvas.addEventListener('mousedown', (e) => {
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  strokeDX = 0; strokeDY = 0;
  if (mode === 'rake') {
    carveRake(x, y, parseInt(slider.value), 0, 0);
  } else {
    pourSand(x, y, parseInt(slider.value));
  }
  requestRender();
});

canvas.addEventListener('mousemove', (e) => {
  const [x, y] = getPos(e);
  // Mark old cursor position dirty so it gets repainted clean
  markCursorDirty();
  mouseX = x; mouseY = y;
  onCanvas = true;
  if (drawing) {
    strokeTo(x, y);
  }
  // Mark new cursor position dirty
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  markCursorDirty();
  rakeAngle += (e.deltaY > 0 ? 1 : -1) * 0.15;
  markCursorDirty();
  requestRender();
}, { passive: false });

canvas.addEventListener('mouseup', () => { drawing = false; });
canvas.addEventListener('mouseleave', () => {
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});
canvas.addEventListener('mouseenter', () => {
  onCanvas = true;
});

// Touch events
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  drawing = true;
  const [x, y] = getPos(e);
  lastX = x; lastY = y;
  mouseX = x; mouseY = y;
  onCanvas = true;
  strokeDX = 0; strokeDY = 0;
  if (mode === 'rake') {
    carveRake(x, y, parseInt(slider.value), 0, 0);
  } else {
    pourSand(x, y, parseInt(slider.value));
  }
  requestRender();
});

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  const [x, y] = getPos(e);
  markCursorDirty();
  mouseX = x; mouseY = y;
  if (drawing) {
    strokeTo(x, y);
  }
  markCursorDirty();
  requestRender();
});

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  markCursorDirty();
  drawing = false;
  onCanvas = false;
  requestRender();
});

clearBtn.addEventListener('click', clearSand);

// --- Mode toggle ---
modeBtn.addEventListener('click', () => {
  markCursorDirty();
  mode = mode === 'rake' ? 'pour' : 'rake';
  modeBtn.textContent = mode === 'rake' ? 'Rake' : 'Pour';
  modeBtn.classList.toggle('active', mode === 'rake');
  markCursorDirty();
  requestRender();
});

// --- Swatch selection ---
document.querySelectorAll('.swatch').forEach(el => {
  el.addEventListener('click', () => {
    document.querySelectorAll('.swatch').forEach(s => s.classList.remove('selected'));
    el.classList.add('selected');
    selectedColor = parseInt(el.dataset.color);
    mode = 'pour';
    modeBtn.textContent = 'Pour';
    modeBtn.classList.remove('active');
    markCursorDirty();
    requestRender();
  });
});

// --- Init ---
initSand();
generateNoiseMap();
markFullDirty();
render();
</script>
</body>
</html>
